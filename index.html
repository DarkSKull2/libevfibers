<!DOCTYPE html>
<html>
  <head>
    <meta charset='utf-8'>
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <link href='https://fonts.googleapis.com/css?family=Chivo:900' rel='stylesheet' type='text/css'>
    <link rel="stylesheet" type="text/css" href="stylesheets/stylesheet.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/pygment_trac.css" media="screen" />
    <link rel="stylesheet" type="text/css" href="stylesheets/print.css" media="print" />
    <!--[if lt IE 9]>
    <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <title>Libevfibers by Lupus</title>
  </head>

  <body>
    <div id="container">
      <div class="inner">

        <header>
          <h1>Libevfibers</h1>
          <h2>Small C fiber library</h2>
        </header>

        <section id="downloads" class="clearfix">
          <a href="https://github.com/Lupus/libevfibers/zipball/master" id="download-zip" class="button"><span>Download .zip</span></a>
          <a href="https://github.com/Lupus/libevfibers/tarball/master" id="download-tar-gz" class="button"><span>Download .tar.gz</span></a>
          <a href="https://github.com/Lupus/libevfibers" id="view-on-github" class="button"><span>View on GitHub</span></a>
        </section>

        <hr>

        <section id="main_content">
          <h1>
<a name="about-libevfibers" class="anchor" href="#about-libevfibers"><span class="octicon octicon-link"></span></a>About libevfibers</h1>

<p>A small C fiber library that uses libev based event loop and libcoro based coroutine context switching. As libcoro alone is barely enough to do something useful, this project aims at building a complete fiber API around it while leveraging high performance and flexibility of libev.</p>

<p>The API documentation for current master along with general description is located <a href="http://lupus.github.io/libevfibers/docs/current/index.html">here</a>.</p>

<h1>
<a name="what-fibers-are-you-speaking-about" class="anchor" href="#what-fibers-are-you-speaking-about"><span class="octicon octicon-link"></span></a>What fibers are you speaking about?</h1>

<p>A fiber is an independent execution context of your program. Unlike classic approach, when you have your `main' being the only execution context, you can have as many of them as you like and switch between them at will. Wait, but that sounds like threads! Well, yes, it really does. Fibers are really similar to threads, but are executed completely in the userspace without any kernel-level scheduling and context switching mechanisms. The main difference between fibers and threads is the scheduling model. Fibers use cooperative multitasking while threads exercise preemptive multitasking. The fibers model requires some cooperation between fibers: if one takes all of the CPU time running in a busy loop (or blocks on e.g. read()) others will not have a chance to run. On the other hand it has some advantages:</p>

<ul>
<li>user space context switching is cheap (just save/restore all registers and adjust a couple of variables in the scheduler)</li>
<li>less synchronization is required --- as you have a guarantee that no other fiber is executed concurrently, you don't have to bother about inter-fiber synchronization (except the cases where you want to guard some code block explicitly, i.e. writing to a shared socket).</li>
</ul><p>Fibers also may be considered as an enhancement of event-loop driven applications as they enable you to put all your business logic in one function instead of splitting it in several callbacks (without an extra processing overhead). For example, if you implement a network protocol, you can just create a fiber per each client connection and use fbr_read_all/fbr_write_all to fully read and write protocol messages. Also you don't have to bother about low-level details of how much data was processed during syscalls and how much left. Your fiber will proceed when the required amount of data is read (or an error occurred). This greatly simplifies the protocol processing logic.</p>

<h1>
<a name="basic-usage-example" class="anchor" href="#basic-usage-example"><span class="octicon octicon-link"></span></a>Basic usage example</h1>

<p>An example is modeled after <a href="http://www.gnu.org/software/pth/pth-manual.html#example">this one</a> and can be found in <a href="https://github.com/Lupus/libevfibers/blob/master/examples/useless_time_server.c">the source tree</a>.</p>

<p>The following example is a simple TCP server that listens on the 12345 port for incoming connections and writes the current time to the client socket if a connection was established. There are fibers of two types: acceptors and handlers. The former accept all incoming connections and create connection handler fibers, the latter process all the communication with connected clients. Additionally, to see more concurrency, a useless ticker fiber runs simultaneously and outputs the current time to the stderr every 5 seconds.</p>

<h1>
<a name="recent-changes" class="anchor" href="#recent-changes"><span class="octicon octicon-link"></span></a>Recent changes</h1>

<h2>
<a name="12-may-2013" class="anchor" href="#12-may-2013"><span class="octicon octicon-link"></span></a>12 May 2013</h2>

<p>I've just released libevfibers 0.3.0!</p>

<p>This release contains important bugfixes and some useful features. Documentation for this release can be found <a href="http://lupus.github.io/libevfibers/docs/v0.3.0/index.html">here</a>. The list of changes follows:</p>

<ul>
<li>Fiber names are now gettable/settable</li>
<li>Also a name is now an array, embedded into a fiber structure to simplify memory management.</li>
<li>Support for fiber-local storage</li>
<li>fbr_reclaim fixes. Now when a fiber is reclaimed, it's filtered out from the stack to make sure that fbr_yield will not ield to a reclaimed fiber. Also fbr_reclaim of self will now never return.</li>
<li>Switched fbr_need_log and fbr_set_log_level to static inline</li>
<li>Now passing real fiber stack size to coro_create</li>
<li>Added ``active'' flag to destructor. To support this I've also added static and dynamic initializers for a destructor structure.</li>
<li>Moved fbr_mutex, fbr_cond_var, fbr_buffer into public API to allow stack allocation of these structures which should result in some speedup.</li>
<li>Protected libev watchers with desctructors. Now when doing fbr_read a destructor is set before fbr_ev_wait that will stop the watcher in case fiber is reclaimed while we were waiting.</li>
<li>ev_now() timestamp in default logger</li>
<li>Fixed fbr_ev_wait_one behaviour to match documentation</li>
<li>Added missing call of destructors upon fiber reclaim</li>
<li>Added stack-allocatable destructor API</li>
<li>More rethinking and reworking of the event facility (see <a href="https://github.com/Lupus/libevfibers/commit/701e0671c29ceaa75882ff25b7fd55a0462d5610">701e067</a>)</li>
</ul><h2>
<a name="9-december-2012" class="anchor" href="#9-december-2012"><span class="octicon octicon-link"></span></a>9 December 2012</h2>

<p>I've just released libevfibers 0.2.0!</p>

<p>API has changed quite a lot from the previous release. Hopefully this API will be more stable and will not be changed that much in the future. Documentation for this release can be found <a href="http://lupus.github.io/libevfibers/docs/v0.2.0/index.html">here</a>. The list of changes follows:</p>

<ul>
<li>Dropped "call" and "multicall" interfaces alltogether</li>
<li>Added fbr_ev_wait and corresponding machinery</li>
<li>Added transactional ring buffer</li>
<li>Implemented error subsystem with f_errno</li>
<li>Fixed ABA problem with reclaimed fibers</li>
<li>Added logging system</li>
<li>Added conditional variables</li>
<li>Minor utility additions to API</li>
<li>Unit tests</li>
</ul>
        </section>

        <footer>
          Libevfibers is maintained by <a href="https://github.com/Lupus">Lupus</a><br>
          This page was generated by <a href="http://pages.github.com">GitHub Pages</a>. Tactile theme by <a href="https://twitter.com/jasonlong">Jason Long</a>.
        </footer>

                  <script type="text/javascript">
            var gaJsHost = (("https:" == document.location.protocol) ? "https://ssl." : "http://www.");
            document.write(unescape("%3Cscript src='" + gaJsHost + "google-analytics.com/ga.js' type='text/javascript'%3E%3C/script%3E"));
          </script>
          <script type="text/javascript">
            try {
              var pageTracker = _gat._getTracker("UA-35569049-2");
            pageTracker._trackPageview();
            } catch(err) {}
          </script>

      </div>
    </div>
  </body>
</html>