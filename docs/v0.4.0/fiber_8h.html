<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<title>libevfibers: include/evfibers/fiber.h File Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
</script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
  $(document).ready(function() { searchBox.OnSelectItem(0); });
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
<script type="text/javascript">
  var _gaq = _gaq || [];

  _gaq.push(['_trackPageview']);
  (function() {
    var ga = document.createElement('script'); ga.type = 'text/javascript'; ga.async = true;
    ga.src = ('https:' == document.location.protocol ? 'https://ssl' : 'http://www') + '.google-analytics.com/ga.js';
    var s = document.getElementsByTagName('script')[0]; s.parentNode.insertBefore(ga, s);
  })();
</script>
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td style="padding-left: 0.5em;">
   <div id="projectname">libevfibers
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.1.2 -->
<script type="text/javascript">
var searchBox = new SearchBox("searchBox", "search",false,'Search');
</script>
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="annotated.html"><span>Data&#160;Structures</span></a></li>
      <li class="current"><a href="files.html"><span>Files</span></a></li>
      <li>
        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
      </li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="files.html"><span>File&#160;List</span></a></li>
      <li><a href="globals.html"><span>Globals</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('fiber_8h.html','');});
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
<a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(0)"><span class="SelectionMark">&#160;</span>All</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(1)"><span class="SelectionMark">&#160;</span>Data Structures</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(2)"><span class="SelectionMark">&#160;</span>Files</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(3)"><span class="SelectionMark">&#160;</span>Functions</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(4)"><span class="SelectionMark">&#160;</span>Variables</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(5)"><span class="SelectionMark">&#160;</span>Typedefs</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(6)"><span class="SelectionMark">&#160;</span>Enumerations</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(7)"><span class="SelectionMark">&#160;</span>Enumerator</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(8)"><span class="SelectionMark">&#160;</span>Macros</a><a class="SelectItem" href="javascript:void(0)" onclick="searchBox.OnSelectItem(9)"><span class="SelectionMark">&#160;</span>Pages</a></div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="header">
  <div class="summary">
<a href="#nested-classes">Data Structures</a> &#124;
<a href="#define-members">Macros</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a> &#124;
<a href="#var-members">Variables</a>  </div>
  <div class="headertitle">
<div class="title">fiber.h File Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>This file contains all client-visible API functions for working with fibers.  
<a href="#details">More...</a></p>
<div class="textblock"><code>#include &lt;unistd.h&gt;</code><br/>
<code>#include &lt;stdarg.h&gt;</code><br/>
<code>#include &lt;stddef.h&gt;</code><br/>
<code>#include &lt;string.h&gt;</code><br/>
<code>#include &lt;stdint.h&gt;</code><br/>
<code>#include &lt;sys/types.h&gt;</code><br/>
<code>#include &lt;sys/socket.h&gt;</code><br/>
<code>#include &lt;sys/queue.h&gt;</code><br/>
<code>#include &lt;assert.h&gt;</code><br/>
<code>#include &lt;ev.h&gt;</code><br/>
<code>#include &lt;evfibers/config.h&gt;</code><br/>
</div>
<p><a href="fiber_8h_source.html">Go to the source code of this file.</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="nested-classes"></a>
Data Structures</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__id__s.html">fbr_id_s</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__context.html">fbr_context</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Library context structure, should be initialized before any other library calls will be performed.  <a href="structfbr__context.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__logger.html">fbr_logger</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logger structure.  <a href="structfbr__logger.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__destructor.html">fbr_destructor</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor structure.  <a href="structfbr__destructor.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__id__tailq__i.html">fbr_id_tailq_i</a></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__ev__base.html">fbr_ev_base</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Base struct for all events.  <a href="structfbr__ev__base.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__ev__watcher.html">fbr_ev_watcher</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">libev watcher event.  <a href="structfbr__ev__watcher.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__ev__mutex.html">fbr_ev_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structfbr__mutex.html" title="Mutex structure.">fbr_mutex</a> event.  <a href="structfbr__ev__mutex.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__ev__cond__var.html">fbr_ev_cond_var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight"><a class="el" href="structfbr__cond__var.html" title="Conditional variable structure.">fbr_cond_var</a> event.  <a href="structfbr__ev__cond__var.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__mutex.html">fbr_mutex</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Mutex structure.  <a href="structfbr__mutex.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__cond__var.html">fbr_cond_var</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Conditional variable structure.  <a href="structfbr__cond__var.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__vrb.html">fbr_vrb</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Virtual ring buffer implementation.  <a href="structfbr__vrb.html#details">More...</a><br/></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structfbr__buffer.html">fbr_buffer</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Inter-fiber communication pipe.  <a href="structfbr__buffer.html#details">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="define-members"></a>
Macros</h2></td></tr>
<tr class="memitem:a5e2639993d3a527ba23afa9141f7d069"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a5e2639993d3a527ba23afa9141f7d069"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5e2639993d3a527ba23afa9141f7d069">FBR_CALL_STACK_SIZE</a>&#160;&#160;&#160;16</td></tr>
<tr class="memdesc:a5e2639993d3a527ba23afa9141f7d069"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum allowed level of fbr_transfer nesting within fibers. <br/></td></tr>
<tr class="memitem:aa18ca95d4c91611089fadeecc6a6ff13"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aa18ca95d4c91611089fadeecc6a6ff13"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#aa18ca95d4c91611089fadeecc6a6ff13">FBR_STACK_SIZE</a>&#160;&#160;&#160;(64 * 1024) /* 64 KB */</td></tr>
<tr class="memdesc:aa18ca95d4c91611089fadeecc6a6ff13"><td class="mdescLeft">&#160;</td><td class="mdescRight">Default stack size for a fiber of 64 KB. <br/></td></tr>
<tr class="memitem:a2921adccfbd51435ecb82c3780916f57"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a2921adccfbd51435ecb82c3780916f57">fbr_assert</a>(context, expr)</td></tr>
<tr class="memdesc:a2921adccfbd51435ecb82c3780916f57"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber version of classic assert.  <a href="#a2921adccfbd51435ecb82c3780916f57"></a><br/></td></tr>
<tr class="memitem:a4b2672b08a4586b81917b71ef7bc8eee"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a4b2672b08a4586b81917b71ef7bc8eee">fbr_container_of</a>(ptr, type, member)</td></tr>
<tr class="memdesc:a4b2672b08a4586b81917b71ef7bc8eee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Just for convenience we have container_of macro here.  <a href="#a4b2672b08a4586b81917b71ef7bc8eee"></a><br/></td></tr>
<tr class="memitem:ab8d0d2be00346d846c594c685bc04914"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab8d0d2be00346d846c594c685bc04914"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>&#160;&#160;&#160;struct <a class="el" href="structfbr__context.html">fbr_context</a> *fctx</td></tr>
<tr class="memdesc:ab8d0d2be00346d846c594c685bc04914"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility macro for context parameter used in function prototypes. <br/></td></tr>
<tr class="memitem:a9a5df8d937d7e862e3782cb83341b780"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a9a5df8d937d7e862e3782cb83341b780"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a9a5df8d937d7e862e3782cb83341b780">FBR_PU</a>&#160;&#160;&#160;__attribute__((unused)) <a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a></td></tr>
<tr class="memdesc:a9a5df8d937d7e862e3782cb83341b780"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as FBR_P but with unused attribute. <br/></td></tr>
<tr class="memitem:a1d223ea2c3abc8cc7e3b4b9f80fb733e"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a1d223ea2c3abc8cc7e3b4b9f80fb733e"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a>&#160;&#160;&#160;<a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>,</td></tr>
<tr class="memdesc:a1d223ea2c3abc8cc7e3b4b9f80fb733e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as FBR_P, but with comma afterwards for use in functions that accept more that one parameter (which itself is the context pointer). <br/></td></tr>
<tr class="memitem:af4be6502fa23d9804b2b178bd3f96f3c"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="af4be6502fa23d9804b2b178bd3f96f3c"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#af4be6502fa23d9804b2b178bd3f96f3c">FBR_PU_</a>&#160;&#160;&#160;__attribute__((unused)) <a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a></td></tr>
<tr class="memdesc:af4be6502fa23d9804b2b178bd3f96f3c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as FBR_P_ but unused attribute. <br/></td></tr>
<tr class="memitem:a859f83b1e62a2e66d9e2b45890a368c5"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a859f83b1e62a2e66d9e2b45890a368c5"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a859f83b1e62a2e66d9e2b45890a368c5">FBR_A</a>&#160;&#160;&#160;fctx</td></tr>
<tr class="memdesc:a859f83b1e62a2e66d9e2b45890a368c5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility macro for context parameter passing when calling fbr_* functions. <br/></td></tr>
<tr class="memitem:adf0be839ad4001538c83fa3637bd7dbe"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="adf0be839ad4001538c83fa3637bd7dbe"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#adf0be839ad4001538c83fa3637bd7dbe">FBR_A_</a>&#160;&#160;&#160;<a class="el" href="fiber_8h.html#a859f83b1e62a2e66d9e2b45890a368c5">FBR_A</a>,</td></tr>
<tr class="memdesc:adf0be839ad4001538c83fa3637bd7dbe"><td class="mdescLeft">&#160;</td><td class="mdescRight">Same as FBR_A, but with comma afterwards for invocations of functions that require more that one parameter (which itself is the context pointer). <br/></td></tr>
<tr class="memitem:a571e933f126cfccd141927a62fd579a7"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><b>FBR_DESTRUCTOR_INITIALIZER</b></td></tr>
<tr class="memitem:ac5a180f9a74fb4049263f54123501bc0"><td class="memItemLeft" align="right" valign="top">#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ac5a180f9a74fb4049263f54123501bc0">fbr_ev_upcast</a>(ptr, type_no_struct)&#160;&#160;&#160;<a class="el" href="fiber_8h.html#a4b2672b08a4586b81917b71ef7bc8eee">fbr_container_of</a>(ptr, struct type_no_struct, ev_base)</td></tr>
<tr class="memdesc:ac5a180f9a74fb4049263f54123501bc0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Convenience macro to save some typing.  <a href="#ac5a180f9a74fb4049263f54123501bc0"></a><br/></td></tr>
<tr class="memitem:ab90268e5d39e751737de0f6aaf71a1c4"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab90268e5d39e751737de0f6aaf71a1c4"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ab90268e5d39e751737de0f6aaf71a1c4">FBR_MAX_KEY</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:ab90268e5d39e751737de0f6aaf71a1c4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum numbef of fiber-local keys allowed. <br/></td></tr>
<tr class="memitem:a6d1cdd23d3dbdb762bb440d5e0b49081"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a6d1cdd23d3dbdb762bb440d5e0b49081"></a>
#define&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a6d1cdd23d3dbdb762bb440d5e0b49081">FBR_MAX_FIBER_NAME</a>&#160;&#160;&#160;64</td></tr>
<tr class="memdesc:a6d1cdd23d3dbdb762bb440d5e0b49081"><td class="mdescLeft">&#160;</td><td class="mdescRight">Maximum length of fiber's name. <br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:ad08a37907434cf705119847ed590a089"><td class="memItemLeft" align="right" valign="top">typedef struct <a class="el" href="structfbr__id__s.html">fbr_id_s</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a></td></tr>
<tr class="memdesc:ad08a37907434cf705119847ed590a089"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber ID type.  <a href="#ad08a37907434cf705119847ed590a089"></a><br/></td></tr>
<tr class="memitem:a7b11ce8e4d8a3cdfe9e7ea43598761b2"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a7b11ce8e4d8a3cdfe9e7ea43598761b2">fbr_fiber_func_t</a> )(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *_arg)</td></tr>
<tr class="memdesc:a7b11ce8e4d8a3cdfe9e7ea43598761b2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber's ``main'' function type.  <a href="#a7b11ce8e4d8a3cdfe9e7ea43598761b2"></a><br/></td></tr>
<tr class="memitem:a68c6e67a55e140618c243d1d1e6d29e7"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a68c6e67a55e140618c243d1d1e6d29e7">fbr_alloc_destructor_func_t</a> )(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *ptr, void *context)</td></tr>
<tr class="memdesc:a68c6e67a55e140618c243d1d1e6d29e7"><td class="mdescLeft">&#160;</td><td class="mdescRight">(DEPRECATED) Destructor function type for the memory allocated in a fiber.  <a href="#a68c6e67a55e140618c243d1d1e6d29e7"></a><br/></td></tr>
<tr class="memitem:abcc45eba652c34b021a4dceddc485135"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135">fbr_log_func_t</a> )(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__logger.html">fbr_logger</a> *logger, enum <a class="el" href="fiber_8h.html#a5d63a523db6c2493dc2b650dcbed9be3">fbr_log_level</a> level, const char *format, va_list ap)</td></tr>
<tr class="memdesc:abcc45eba652c34b021a4dceddc485135"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logger function type.  <a href="#abcc45eba652c34b021a4dceddc485135"></a><br/></td></tr>
<tr class="memitem:a0a1d0579fe89b13fab05a3ad54e61188"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188">fbr_logutil_func_t</a> )(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *format,...)</td></tr>
<tr class="memdesc:a0a1d0579fe89b13fab05a3ad54e61188"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logger utility function type.  <a href="#a0a1d0579fe89b13fab05a3ad54e61188"></a><br/></td></tr>
<tr class="memitem:a95e135c1ab08d957fcde1e5baf21a43e"><td class="memItemLeft" align="right" valign="top">typedef void(*&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a95e135c1ab08d957fcde1e5baf21a43e">fbr_destructor_func_t</a> )(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *arg)</td></tr>
<tr class="memdesc:a95e135c1ab08d957fcde1e5baf21a43e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destructor function type.  <a href="#a95e135c1ab08d957fcde1e5baf21a43e"></a><br/></td></tr>
<tr class="memitem:a6a327243ec5baeb5b3145c6624d0977c"><td class="memItemLeft" align="right" valign="top">typedef unsigned int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a></td></tr>
<tr class="memdesc:a6a327243ec5baeb5b3145c6624d0977c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber-local data key.  <a href="#a6a327243ec5baeb5b3145c6624d0977c"></a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:a4b8cb982994caa4c72046dd2970fa5a6"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a4b8cb982994caa4c72046dd2970fa5a6">fbr_error_code</a> { <br/>
&#160;&#160;<b>FBR_SUCCESS</b> =  0, 
<b>FBR_EINVAL</b>, 
<b>FBR_ENOFIBER</b>, 
<b>FBR_ESYSTEM</b>, 
<br/>
&#160;&#160;<b>FBR_EBUFFERMMAP</b>, 
<b>FBR_ENOKEY</b>, 
<b>FBR_EPROTOBUF</b>, 
<b>FBR_EBUFFERNOSPACE</b>, 
<br/>
&#160;&#160;<b>FBR_EEIO</b>
<br/>
 }</td></tr>
<tr class="memdesc:a4b8cb982994caa4c72046dd2970fa5a6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Error codes used within the library.  <a href="fiber_8h.html#a4b8cb982994caa4c72046dd2970fa5a6">More...</a><br/></td></tr>
<tr class="memitem:a5d63a523db6c2493dc2b650dcbed9be3"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5d63a523db6c2493dc2b650dcbed9be3">fbr_log_level</a> { <br/>
&#160;&#160;<b>FBR_LOG_ERROR</b> =  0, 
<b>FBR_LOG_WARNING</b>, 
<b>FBR_LOG_NOTICE</b>, 
<b>FBR_LOG_INFO</b>, 
<br/>
&#160;&#160;<b>FBR_LOG_DEBUG</b>
<br/>
 }</td></tr>
<tr class="memdesc:a5d63a523db6c2493dc2b650dcbed9be3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Logging levels.  <a href="fiber_8h.html#a5d63a523db6c2493dc2b650dcbed9be3">More...</a><br/></td></tr>
<tr class="memitem:a61e29a575eecbcfef017b66bee4409ee"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a61e29a575eecbcfef017b66bee4409ee">fbr_ev_type</a> { <a class="el" href="fiber_8h.html#a61e29a575eecbcfef017b66bee4409eea6a6285430da9ea418e18093929066d35">FBR_EV_WATCHER</a> =  1, 
<a class="el" href="fiber_8h.html#a61e29a575eecbcfef017b66bee4409eea200a3dc22cf18bfbcc9fe1201c2198a5">FBR_EV_MUTEX</a>, 
<a class="el" href="fiber_8h.html#a61e29a575eecbcfef017b66bee4409eeaf1250fc8e958238e6347f1373623224f">FBR_EV_COND_VAR</a>, 
<a class="el" href="fiber_8h.html#a61e29a575eecbcfef017b66bee4409eea0854994f9f2dfe14081bb798ca503516">FBR_EV_EIO</a>
 }</td></tr>
<tr class="memdesc:a61e29a575eecbcfef017b66bee4409ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Type of events supported by the library.  <a href="fiber_8h.html#a61e29a575eecbcfef017b66bee4409ee">More...</a><br/></td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:ac202ff0cf3f815a50591931023645f55"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac202ff0cf3f815a50591931023645f55"></a>
struct <a class="el" href="structfbr__id__s.html">fbr_id_s</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b> ((packed))</td></tr>
<tr class="memitem:a921cc001370f2d343dd927280a036096"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a921cc001370f2d343dd927280a036096"></a>
&#160;</td><td class="memItemRight" valign="bottom"><b>TAILQ_HEAD</b> (fbr_id_tailq, <a class="el" href="structfbr__id__tailq__i.html">fbr_id_tailq_i</a>)</td></tr>
<tr class="memitem:ac459666cfb5bf34e4dd651f343f8783e"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ac459666cfb5bf34e4dd651f343f8783e">fbr_destructor_add</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__destructor.html">fbr_destructor</a> *dtor)</td></tr>
<tr class="memdesc:ac459666cfb5bf34e4dd651f343f8783e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Adds destructor to fiber list.  <a href="#ac459666cfb5bf34e4dd651f343f8783e"></a><br/></td></tr>
<tr class="memitem:a0d67f581b2398fac8bfc0a35af698ad4"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a0d67f581b2398fac8bfc0a35af698ad4">fbr_destructor_remove</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__destructor.html">fbr_destructor</a> *dtor, int call)</td></tr>
<tr class="memdesc:a0d67f581b2398fac8bfc0a35af698ad4"><td class="mdescLeft">&#160;</td><td class="mdescRight">Removes destructor from fiber list.  <a href="#a0d67f581b2398fac8bfc0a35af698ad4"></a><br/></td></tr>
<tr class="memitem:a8f7c8a5bfe2a9b6e24ec0bcce50e6617"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a8f7c8a5bfe2a9b6e24ec0bcce50e6617">fbr_ev_watcher_init</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__watcher.html">fbr_ev_watcher</a> *ev, ev_watcher *w)</td></tr>
<tr class="memdesc:a8f7c8a5bfe2a9b6e24ec0bcce50e6617"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for libev watcher event.  <a href="#a8f7c8a5bfe2a9b6e24ec0bcce50e6617"></a><br/></td></tr>
<tr class="memitem:aed73b4ac7962689d4518f9a8ce88d290"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#aed73b4ac7962689d4518f9a8ce88d290">fbr_ev_mutex_init</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__mutex.html">fbr_ev_mutex</a> *ev, struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:aed73b4ac7962689d4518f9a8ce88d290"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for mutex event.  <a href="#aed73b4ac7962689d4518f9a8ce88d290"></a><br/></td></tr>
<tr class="memitem:a5a246c700c9fed3bf8d5ef049156eaae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5a246c700c9fed3bf8d5ef049156eaae">fbr_ev_cond_var_init</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__cond__var.html">fbr_ev_cond_var</a> *ev, struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *cond, struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a5a246c700c9fed3bf8d5ef049156eaae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializer for conditional variable event.  <a href="#a5a246c700c9fed3bf8d5ef049156eaae"></a><br/></td></tr>
<tr class="memitem:a8b2ecf950d76464077b2d4e39036eb47"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a8b2ecf950d76464077b2d4e39036eb47">fbr_ev_wait_one</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__base.html">fbr_ev_base</a> *one)</td></tr>
<tr class="memdesc:a8b2ecf950d76464077b2d4e39036eb47"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event awaiting function (one event only wrapper).  <a href="#a8b2ecf950d76464077b2d4e39036eb47"></a><br/></td></tr>
<tr class="memitem:a66566b61e09d8cb20908f952f319a2cf"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a66566b61e09d8cb20908f952f319a2cf">fbr_ev_wait</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__base.html">fbr_ev_base</a> *events[])</td></tr>
<tr class="memdesc:a66566b61e09d8cb20908f952f319a2cf"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event awaiting function (generic one).  <a href="#a66566b61e09d8cb20908f952f319a2cf"></a><br/></td></tr>
<tr class="memitem:a845bb0c84adde64be31c8a3c3b0c5f2e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a845bb0c84adde64be31c8a3c3b0c5f2e">fbr_ev_wait_to</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__base.html">fbr_ev_base</a> *events[], ev_tstamp timeout)</td></tr>
<tr class="memdesc:a845bb0c84adde64be31c8a3c3b0c5f2e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Event awaiting function with timeout.  <a href="#a845bb0c84adde64be31c8a3c3b0c5f2e"></a><br/></td></tr>
<tr class="memitem:a0e6f58c891a8cbf336bdd677314e535c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a0e6f58c891a8cbf336bdd677314e535c">fbr_transfer</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> to)</td></tr>
<tr class="memdesc:a0e6f58c891a8cbf336bdd677314e535c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Transfer of fiber context to another fiber.  <a href="#a0e6f58c891a8cbf336bdd677314e535c"></a><br/></td></tr>
<tr class="memitem:a5aae42537a1db369f308cba59985b662"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5aae42537a1db369f308cba59985b662">fbr_init</a> (struct <a class="el" href="structfbr__context.html">fbr_context</a> *fctx, struct ev_loop *loop)</td></tr>
<tr class="memdesc:a5aae42537a1db369f308cba59985b662"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes the library context.  <a href="#a5aae42537a1db369f308cba59985b662"></a><br/></td></tr>
<tr class="memitem:ae2d252e157ba838c56dbe4ab5b061e7f"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ae2d252e157ba838c56dbe4ab5b061e7f">fbr_destroy</a> (<a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>)</td></tr>
<tr class="memdesc:ae2d252e157ba838c56dbe4ab5b061e7f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys the library context.  <a href="#ae2d252e157ba838c56dbe4ab5b061e7f"></a><br/></td></tr>
<tr class="memitem:ad4632e5653fe6aed586b9dfd23716708"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ad4632e5653fe6aed586b9dfd23716708">fbr_enable_backtraces</a> (<a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>, int enabled)</td></tr>
<tr class="memdesc:ad4632e5653fe6aed586b9dfd23716708"><td class="mdescLeft">&#160;</td><td class="mdescRight">Enables/Disables backtrace capturing.  <a href="#ad4632e5653fe6aed586b9dfd23716708"></a><br/></td></tr>
<tr class="memitem:a490cd2689aedc1ca0e60404a47b7f550"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a490cd2689aedc1ca0e60404a47b7f550">fbr_strerror</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> enum <a class="el" href="fiber_8h.html#a4b8cb982994caa4c72046dd2970fa5a6">fbr_error_code</a> code)</td></tr>
<tr class="memdesc:a490cd2689aedc1ca0e60404a47b7f550"><td class="mdescLeft">&#160;</td><td class="mdescRight">Analog of strerror but for the library errno.  <a href="#a490cd2689aedc1ca0e60404a47b7f550"></a><br/></td></tr>
<tr class="memitem:a1175cd695bd850bfb6d277432e0e7a0c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a1175cd695bd850bfb6d277432e0e7a0c">fbr_log_e</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *format,...) __attribute__((format(printf</td></tr>
<tr class="memdesc:a1175cd695bd850bfb6d277432e0e7a0c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility log wrapper.  <a href="#a1175cd695bd850bfb6d277432e0e7a0c"></a><br/></td></tr>
<tr class="memitem:a5a69c39229c1d71f9391682e994c1ed0"><td class="memItemLeft" align="right" valign="top">void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5a69c39229c1d71f9391682e994c1ed0">fbr_log_w</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *format,...) __attribute__((format(printf</td></tr>
<tr class="memdesc:a5a69c39229c1d71f9391682e994c1ed0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility log wrapper.  <a href="#a5a69c39229c1d71f9391682e994c1ed0"></a><br/></td></tr>
<tr class="memitem:ae2bf0d14636801edb0d66dc388a2616f"><td class="memItemLeft" align="right" valign="top">void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ae2bf0d14636801edb0d66dc388a2616f">fbr_log_n</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *format,...) __attribute__((format(printf</td></tr>
<tr class="memdesc:ae2bf0d14636801edb0d66dc388a2616f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility log wrapper.  <a href="#ae2bf0d14636801edb0d66dc388a2616f"></a><br/></td></tr>
<tr class="memitem:aa815bc8cf6b125b76e852a41dd488812"><td class="memItemLeft" align="right" valign="top">void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#aa815bc8cf6b125b76e852a41dd488812">fbr_log_i</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *format,...) __attribute__((format(printf</td></tr>
<tr class="memdesc:aa815bc8cf6b125b76e852a41dd488812"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility log wrapper.  <a href="#aa815bc8cf6b125b76e852a41dd488812"></a><br/></td></tr>
<tr class="memitem:ad72c35cd4b120be1c6e97c45f50dc6dc"><td class="memItemLeft" align="right" valign="top">void void void void void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ad72c35cd4b120be1c6e97c45f50dc6dc">fbr_log_d</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *format,...) __attribute__((format(printf</td></tr>
<tr class="memdesc:ad72c35cd4b120be1c6e97c45f50dc6dc"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility log wrapper.  <a href="#ad72c35cd4b120be1c6e97c45f50dc6dc"></a><br/></td></tr>
<tr class="memitem:a9b28e140133bb8af4fe33053f2c5285b"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a9b28e140133bb8af4fe33053f2c5285b">fbr_create</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *name, <a class="el" href="fiber_8h.html#a7b11ce8e4d8a3cdfe9e7ea43598761b2">fbr_fiber_func_t</a> func, void *arg, size_t stack_size)</td></tr>
<tr class="memdesc:a9b28e140133bb8af4fe33053f2c5285b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new fiber.  <a href="#a9b28e140133bb8af4fe33053f2c5285b"></a><br/></td></tr>
<tr class="memitem:a8ca58482ab7f2386cee302b51f58ef2b"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a8ca58482ab7f2386cee302b51f58ef2b">fbr_get_name</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> id)</td></tr>
<tr class="memdesc:a8ca58482ab7f2386cee302b51f58ef2b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Retrieve a name of the fiber.  <a href="#a8ca58482ab7f2386cee302b51f58ef2b"></a><br/></td></tr>
<tr class="memitem:ade47de6332577b83545d4e424ab1c5d1"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ade47de6332577b83545d4e424ab1c5d1">fbr_set_name</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> id, const char *name)</td></tr>
<tr class="memdesc:ade47de6332577b83545d4e424ab1c5d1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets a name for the fiber.  <a href="#ade47de6332577b83545d4e424ab1c5d1"></a><br/></td></tr>
<tr class="memitem:a4b42ab908f71c52ce8c64cefd38c50ee"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a4b42ab908f71c52ce8c64cefd38c50ee">fbr_disown</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> parent)</td></tr>
<tr class="memdesc:a4b42ab908f71c52ce8c64cefd38c50ee"><td class="mdescLeft">&#160;</td><td class="mdescRight">Changes parent of current fiber.  <a href="#a4b42ab908f71c52ce8c64cefd38c50ee"></a><br/></td></tr>
<tr class="memitem:a558d2d2ccef531e2c8759388d38658aa"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a558d2d2ccef531e2c8759388d38658aa">fbr_parent</a> (<a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>)</td></tr>
<tr class="memdesc:a558d2d2ccef531e2c8759388d38658aa"><td class="mdescLeft">&#160;</td><td class="mdescRight">Find out current fiber's parent.  <a href="#a558d2d2ccef531e2c8759388d38658aa"></a><br/></td></tr>
<tr class="memitem:a55e114145e071051ae58315dc4de5702"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a55e114145e071051ae58315dc4de5702">fbr_reclaim</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fiber)</td></tr>
<tr class="memdesc:a55e114145e071051ae58315dc4de5702"><td class="mdescLeft">&#160;</td><td class="mdescRight">Reclaims a fiber.  <a href="#a55e114145e071051ae58315dc4de5702"></a><br/></td></tr>
<tr class="memitem:ab6f89dbaabdaab11ca25026987acc519"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ab6f89dbaabdaab11ca25026987acc519"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fbr_set_reclaim</b> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fiber)</td></tr>
<tr class="memitem:ad8ac8c1cb9f954f27f66fe094fca22b7"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ad8ac8c1cb9f954f27f66fe094fca22b7"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fbr_set_noreclaim</b> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fiber)</td></tr>
<tr class="memitem:a65c8a34154960644352e9dbf50aa3181"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a65c8a34154960644352e9dbf50aa3181"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fbr_want_reclaim</b> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fiber)</td></tr>
<tr class="memitem:a5a1228e6d3c768a4b91f265de750c14a"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5a1228e6d3c768a4b91f265de750c14a">fbr_is_reclaimed</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fiber)</td></tr>
<tr class="memdesc:a5a1228e6d3c768a4b91f265de750c14a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tests if given fiber is reclaimed.  <a href="#a5a1228e6d3c768a4b91f265de750c14a"></a><br/></td></tr>
<tr class="memitem:a91c339204d8fb63e6cb35b27e96eaa9e"><td class="memItemLeft" align="right" valign="top"><a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a91c339204d8fb63e6cb35b27e96eaa9e">fbr_self</a> (<a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>)</td></tr>
<tr class="memdesc:a91c339204d8fb63e6cb35b27e96eaa9e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns id of current fiber.  <a href="#a91c339204d8fb63e6cb35b27e96eaa9e"></a><br/></td></tr>
<tr class="memitem:a9fe6e2b8e563ba4952b0a70897303d53"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a9fe6e2b8e563ba4952b0a70897303d53">fbr_key_create</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a> *key)</td></tr>
<tr class="memdesc:a9fe6e2b8e563ba4952b0a70897303d53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber-local key creation.  <a href="#a9fe6e2b8e563ba4952b0a70897303d53"></a><br/></td></tr>
<tr class="memitem:a2adf94a9da3b680795a8d900526f7959"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a2adf94a9da3b680795a8d900526f7959">fbr_key_delete</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a> key)</td></tr>
<tr class="memdesc:a2adf94a9da3b680795a8d900526f7959"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber-local key deletion.  <a href="#a2adf94a9da3b680795a8d900526f7959"></a><br/></td></tr>
<tr class="memitem:a25c57588776af549c18e68c5022a8a5e"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a25c57588776af549c18e68c5022a8a5e">fbr_key_set</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> id, <a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a> key, void *value)</td></tr>
<tr class="memdesc:a25c57588776af549c18e68c5022a8a5e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets fiber-local key data.  <a href="#a25c57588776af549c18e68c5022a8a5e"></a><br/></td></tr>
<tr class="memitem:af8ba856b12a7d5d82bec65d959484e46"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#af8ba856b12a7d5d82bec65d959484e46">fbr_key_get</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> id, <a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a> key)</td></tr>
<tr class="memdesc:af8ba856b12a7d5d82bec65d959484e46"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets fiber-local key data.  <a href="#af8ba856b12a7d5d82bec65d959484e46"></a><br/></td></tr>
<tr class="memitem:aac7f380431691642e6ef83962fb77ea1"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#aac7f380431691642e6ef83962fb77ea1">fbr_yield</a> (<a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>)</td></tr>
<tr class="memdesc:aac7f380431691642e6ef83962fb77ea1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields execution to other fiber.  <a href="#aac7f380431691642e6ef83962fb77ea1"></a><br/></td></tr>
<tr class="memitem:a9d7bedaf3d6d32f2ed0b2f400a5970a5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a9d7bedaf3d6d32f2ed0b2f400a5970a5">fbr_cooperate</a> (<a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>)</td></tr>
<tr class="memdesc:a9d7bedaf3d6d32f2ed0b2f400a5970a5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Yields execution to other fiber returning the execution at the next event loop run.  <a href="#a9d7bedaf3d6d32f2ed0b2f400a5970a5"></a><br/></td></tr>
<tr class="memitem:a3ae27c65ecf583df59641af718d7b854"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a3ae27c65ecf583df59641af718d7b854">fbr_alloc</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> size_t size)</td></tr>
<tr class="memdesc:a3ae27c65ecf583df59641af718d7b854"><td class="mdescLeft">&#160;</td><td class="mdescRight">(DEPRECATED) Allocates memory in current fiber's pool.  <a href="#a3ae27c65ecf583df59641af718d7b854"></a><br/></td></tr>
<tr class="memitem:ac02d87e0172f8765a5caeda2ab33afae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ac02d87e0172f8765a5caeda2ab33afae">fbr_alloc_set_destructor</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *ptr, <a class="el" href="fiber_8h.html#a68c6e67a55e140618c243d1d1e6d29e7">fbr_alloc_destructor_func_t</a> func, void *context)</td></tr>
<tr class="memdesc:ac02d87e0172f8765a5caeda2ab33afae"><td class="mdescLeft">&#160;</td><td class="mdescRight">(DEPRECATED) Sets destructor for a memory chunk.  <a href="#ac02d87e0172f8765a5caeda2ab33afae"></a><br/></td></tr>
<tr class="memitem:ab5d442e97e9f8d321ad564ed1351fc56"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ab5d442e97e9f8d321ad564ed1351fc56">fbr_calloc</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> unsigned int nmemb, size_t size)</td></tr>
<tr class="memdesc:ab5d442e97e9f8d321ad564ed1351fc56"><td class="mdescLeft">&#160;</td><td class="mdescRight">(DEPRECATED) Allocates a set of initialized objects in fiber's pool.  <a href="#ab5d442e97e9f8d321ad564ed1351fc56"></a><br/></td></tr>
<tr class="memitem:a319b2aba4ccfa51fd1fb8b6ecb6dc90c"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a319b2aba4ccfa51fd1fb8b6ecb6dc90c">fbr_free</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *ptr)</td></tr>
<tr class="memdesc:a319b2aba4ccfa51fd1fb8b6ecb6dc90c"><td class="mdescLeft">&#160;</td><td class="mdescRight">(DEPRECATED) Explicitly frees allocated memory chunk.  <a href="#a319b2aba4ccfa51fd1fb8b6ecb6dc90c"></a><br/></td></tr>
<tr class="memitem:a8a685149a3574f43a1e2ca064ddcf09d"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a8a685149a3574f43a1e2ca064ddcf09d">fbr_free_nd</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *ptr)</td></tr>
<tr class="memdesc:a8a685149a3574f43a1e2ca064ddcf09d"><td class="mdescLeft">&#160;</td><td class="mdescRight">(DEPRECATED) Explicitly frees allocated memory chunk.  <a href="#a8a685149a3574f43a1e2ca064ddcf09d"></a><br/></td></tr>
<tr class="memitem:a6d9713d1024c384f4fd2ac9bbf1df760"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a6d9713d1024c384f4fd2ac9bbf1df760">fbr_fd_nonblock</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int fd)</td></tr>
<tr class="memdesc:a6d9713d1024c384f4fd2ac9bbf1df760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to make file descriptor non-blocking.  <a href="#a6d9713d1024c384f4fd2ac9bbf1df760"></a><br/></td></tr>
<tr class="memitem:a3abd87ac5934036fd81c762fc2d7af69"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a3abd87ac5934036fd81c762fc2d7af69">fbr_connect</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int sockfd, const struct sockaddr *addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:a3abd87ac5934036fd81c762fc2d7af69"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly connect wrapper.  <a href="#a3abd87ac5934036fd81c762fc2d7af69"></a><br/></td></tr>
<tr class="memitem:a6b13f824e8810e439fe5356d021eb8a0"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a6b13f824e8810e439fe5356d021eb8a0">fbr_read</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int fd, void *buf, size_t count)</td></tr>
<tr class="memdesc:a6b13f824e8810e439fe5356d021eb8a0"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly libc read wrapper.  <a href="#a6b13f824e8810e439fe5356d021eb8a0"></a><br/></td></tr>
<tr class="memitem:ad83bfc4ecfcab4d968e599be39b7d4df"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ad83bfc4ecfcab4d968e599be39b7d4df">fbr_read_all</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int fd, void *buf, size_t count)</td></tr>
<tr class="memdesc:ad83bfc4ecfcab4d968e599be39b7d4df"><td class="mdescLeft">&#160;</td><td class="mdescRight">Even more fiber friendly libc read wrapper.  <a href="#ad83bfc4ecfcab4d968e599be39b7d4df"></a><br/></td></tr>
<tr class="memitem:a7610e6294cd13295352a26293ebb1cef"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a7610e6294cd13295352a26293ebb1cef">fbr_readline</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int fd, void *buffer, size_t n)</td></tr>
<tr class="memdesc:a7610e6294cd13295352a26293ebb1cef"><td class="mdescLeft">&#160;</td><td class="mdescRight">Utility function to read a line.  <a href="#a7610e6294cd13295352a26293ebb1cef"></a><br/></td></tr>
<tr class="memitem:a4ebe4a182414d71fc76c0e18b5d7b63f"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a4ebe4a182414d71fc76c0e18b5d7b63f">fbr_write</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int fd, const void *buf, size_t count)</td></tr>
<tr class="memdesc:a4ebe4a182414d71fc76c0e18b5d7b63f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly libc write wrapper.  <a href="#a4ebe4a182414d71fc76c0e18b5d7b63f"></a><br/></td></tr>
<tr class="memitem:ab16cc864979562e8b06eb26c7516a98d"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ab16cc864979562e8b06eb26c7516a98d">fbr_write_all</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int fd, const void *buf, size_t count)</td></tr>
<tr class="memdesc:ab16cc864979562e8b06eb26c7516a98d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Even more fiber friendly libc write wrapper.  <a href="#ab16cc864979562e8b06eb26c7516a98d"></a><br/></td></tr>
<tr class="memitem:af81cbfa2b930dcfa0a4bb583bd8fb200"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#af81cbfa2b930dcfa0a4bb583bd8fb200">fbr_recvfrom</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int sockfd, void *buf, size_t len, int flags, struct sockaddr *src_addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:af81cbfa2b930dcfa0a4bb583bd8fb200"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly libc recvfrom wrapper.  <a href="#af81cbfa2b930dcfa0a4bb583bd8fb200"></a><br/></td></tr>
<tr class="memitem:ae2012bda21beeb68ac2ba999b3b5214c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ae2012bda21beeb68ac2ba999b3b5214c">fbr_recv</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int sockfd, void *buf, size_t len, int flags)</td></tr>
<tr class="memdesc:ae2012bda21beeb68ac2ba999b3b5214c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly libc recv wrapper.  <a href="#ae2012bda21beeb68ac2ba999b3b5214c"></a><br/></td></tr>
<tr class="memitem:a4fd5418def62a64016aa8275a380e20e"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a4fd5418def62a64016aa8275a380e20e">fbr_sendto</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int sockfd, const void *buf, size_t len, int flags, const struct sockaddr *dest_addr, socklen_t addrlen)</td></tr>
<tr class="memdesc:a4fd5418def62a64016aa8275a380e20e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly libc sendto wrapper.  <a href="#a4fd5418def62a64016aa8275a380e20e"></a><br/></td></tr>
<tr class="memitem:aca093ce5ce596e42bc5372be92c81b7c"><td class="memItemLeft" align="right" valign="top">ssize_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#aca093ce5ce596e42bc5372be92c81b7c">fbr_send</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int sockfd, const void *buf, size_t len, int flags)</td></tr>
<tr class="memdesc:aca093ce5ce596e42bc5372be92c81b7c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly libc send wrapper.  <a href="#aca093ce5ce596e42bc5372be92c81b7c"></a><br/></td></tr>
<tr class="memitem:a3faee7c5804a20b08b77aa43eb29f69c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a3faee7c5804a20b08b77aa43eb29f69c">fbr_accept</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int sockfd, struct sockaddr *addr, socklen_t *addrlen)</td></tr>
<tr class="memdesc:a3faee7c5804a20b08b77aa43eb29f69c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Fiber friendly libc accept wrapper.  <a href="#a3faee7c5804a20b08b77aa43eb29f69c"></a><br/></td></tr>
<tr class="memitem:ac13bb8634c1e28ca12b86e8c1a298545"><td class="memItemLeft" align="right" valign="top">ev_tstamp&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ac13bb8634c1e28ca12b86e8c1a298545">fbr_sleep</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> ev_tstamp seconds)</td></tr>
<tr class="memdesc:ac13bb8634c1e28ca12b86e8c1a298545"><td class="mdescLeft">&#160;</td><td class="mdescRight">Puts current fiber to sleep.  <a href="#ac13bb8634c1e28ca12b86e8c1a298545"></a><br/></td></tr>
<tr class="memitem:a3b6b21326ccf1a23fd96c11c4b9b3b81"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a3b6b21326ccf1a23fd96c11c4b9b3b81">fbr_dump_stack</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188">fbr_logutil_func_t</a> log)</td></tr>
<tr class="memdesc:a3b6b21326ccf1a23fd96c11c4b9b3b81"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prints fiber call stack to stderr.  <a href="#a3b6b21326ccf1a23fd96c11c4b9b3b81"></a><br/></td></tr>
<tr class="memitem:a5cb28512c5d778bb621fdf3e633fa461"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5cb28512c5d778bb621fdf3e633fa461">fbr_mutex_init</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a5cb28512c5d778bb621fdf3e633fa461"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a mutex.  <a href="#a5cb28512c5d778bb621fdf3e633fa461"></a><br/></td></tr>
<tr class="memitem:a469e97dc647b4d362806ddbafacd9fea"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a469e97dc647b4d362806ddbafacd9fea">fbr_mutex_lock</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a469e97dc647b4d362806ddbafacd9fea"><td class="mdescLeft">&#160;</td><td class="mdescRight">Locks a mutex.  <a href="#a469e97dc647b4d362806ddbafacd9fea"></a><br/></td></tr>
<tr class="memitem:a4e384456743a5e0a5c00d23463726681"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a4e384456743a5e0a5c00d23463726681">fbr_mutex_trylock</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a4e384456743a5e0a5c00d23463726681"><td class="mdescLeft">&#160;</td><td class="mdescRight">Tries to locks a mutex.  <a href="#a4e384456743a5e0a5c00d23463726681"></a><br/></td></tr>
<tr class="memitem:a4a0d3e801f81b9d0d2d12a161f2aa134"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a4a0d3e801f81b9d0d2d12a161f2aa134">fbr_mutex_unlock</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a4a0d3e801f81b9d0d2d12a161f2aa134"><td class="mdescLeft">&#160;</td><td class="mdescRight">Unlocks a mutex.  <a href="#a4a0d3e801f81b9d0d2d12a161f2aa134"></a><br/></td></tr>
<tr class="memitem:a8dce5f86a2fbcbd59863ddb7dd882ec5"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a8dce5f86a2fbcbd59863ddb7dd882ec5">fbr_mutex_destroy</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a8dce5f86a2fbcbd59863ddb7dd882ec5"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a mutex.  <a href="#a8dce5f86a2fbcbd59863ddb7dd882ec5"></a><br/></td></tr>
<tr class="memitem:a7ce468de0b1706afe9a3635302418705"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a7ce468de0b1706afe9a3635302418705">fbr_cond_init</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *cond)</td></tr>
<tr class="memdesc:a7ce468de0b1706afe9a3635302418705"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a conditional variable.  <a href="#a7ce468de0b1706afe9a3635302418705"></a><br/></td></tr>
<tr class="memitem:a1a852b3dc4dd0c187845618843d1aea2"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a1a852b3dc4dd0c187845618843d1aea2">fbr_cond_destroy</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *cond)</td></tr>
<tr class="memdesc:a1a852b3dc4dd0c187845618843d1aea2"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a conditional variable.  <a href="#a1a852b3dc4dd0c187845618843d1aea2"></a><br/></td></tr>
<tr class="memitem:a7d7705e044c32657c1ea5e85f246db4f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a7d7705e044c32657c1ea5e85f246db4f">fbr_cond_wait</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *cond, struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *mutex)</td></tr>
<tr class="memdesc:a7d7705e044c32657c1ea5e85f246db4f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Waits until condition is met.  <a href="#a7d7705e044c32657c1ea5e85f246db4f"></a><br/></td></tr>
<tr class="memitem:a311a4af921fa667d7c85fa0ea25e4206"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a311a4af921fa667d7c85fa0ea25e4206">fbr_cond_broadcast</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *cond)</td></tr>
<tr class="memdesc:a311a4af921fa667d7c85fa0ea25e4206"><td class="mdescLeft">&#160;</td><td class="mdescRight">Broadcasts a signal to all fibers waiting for condition.  <a href="#a311a4af921fa667d7c85fa0ea25e4206"></a><br/></td></tr>
<tr class="memitem:aa48cc22cabc0aa4f8426ac566cf93eed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#aa48cc22cabc0aa4f8426ac566cf93eed">fbr_cond_signal</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *cond)</td></tr>
<tr class="memdesc:aa48cc22cabc0aa4f8426ac566cf93eed"><td class="mdescLeft">&#160;</td><td class="mdescRight">Signals to first fiber waiting for a condition.  <a href="#aa48cc22cabc0aa4f8426ac566cf93eed"></a><br/></td></tr>
<tr class="memitem:ad5cc8bd85290403c550612114dfc960b"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ad5cc8bd85290403c550612114dfc960b">fbr_vrb_init</a> (struct <a class="el" href="structfbr__vrb.html">fbr_vrb</a> *vrb, size_t size, const char *file_pattern)</td></tr>
<tr class="memdesc:ad5cc8bd85290403c550612114dfc960b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes memory mappings.  <a href="#ad5cc8bd85290403c550612114dfc960b"></a><br/></td></tr>
<tr class="memitem:ac88be5097d268184abc535adc0dbb00b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ac88be5097d268184abc535adc0dbb00b">fbr_vrb_destroy</a> (struct <a class="el" href="structfbr__vrb.html">fbr_vrb</a> *vrb)</td></tr>
<tr class="memdesc:ac88be5097d268184abc535adc0dbb00b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys mappings.  <a href="#ac88be5097d268184abc535adc0dbb00b"></a><br/></td></tr>
<tr class="memitem:aabdc0a83d5b4ff7618100f971921837d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aabdc0a83d5b4ff7618100f971921837d"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fbr_vrb_resize_do</b> (struct <a class="el" href="structfbr__vrb.html">fbr_vrb</a> *vrb, size_t new_size, const char *file_pattern)</td></tr>
<tr class="memitem:addee07a0306f1962c3d48b8a3a75221c"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#addee07a0306f1962c3d48b8a3a75221c">fbr_buffer_init</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer, size_t size)</td></tr>
<tr class="memdesc:addee07a0306f1962c3d48b8a3a75221c"><td class="mdescLeft">&#160;</td><td class="mdescRight">Initializes a circular buffer with pipe semantics.  <a href="#addee07a0306f1962c3d48b8a3a75221c"></a><br/></td></tr>
<tr class="memitem:a9bcb12effba786b481727451f8fee279"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a9bcb12effba786b481727451f8fee279">fbr_buffer_destroy</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer)</td></tr>
<tr class="memdesc:a9bcb12effba786b481727451f8fee279"><td class="mdescLeft">&#160;</td><td class="mdescRight">Destroys a circular buffer.  <a href="#a9bcb12effba786b481727451f8fee279"></a><br/></td></tr>
<tr class="memitem:aa42cff2b51a686cf8c709eab00dcd2d3"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#aa42cff2b51a686cf8c709eab00dcd2d3">fbr_buffer_alloc_prepare</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer, size_t size)</td></tr>
<tr class="memdesc:aa42cff2b51a686cf8c709eab00dcd2d3"><td class="mdescLeft">&#160;</td><td class="mdescRight">Prepares a chunk of memory to be committed to buffer.  <a href="#aa42cff2b51a686cf8c709eab00dcd2d3"></a><br/></td></tr>
<tr class="memitem:a13f334f3b42aebcce64fbbd6f353eeae"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a13f334f3b42aebcce64fbbd6f353eeae">fbr_buffer_alloc_commit</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer)</td></tr>
<tr class="memdesc:a13f334f3b42aebcce64fbbd6f353eeae"><td class="mdescLeft">&#160;</td><td class="mdescRight">Commits a chunk of memory to the buffer.  <a href="#a13f334f3b42aebcce64fbbd6f353eeae"></a><br/></td></tr>
<tr class="memitem:a2fe9fb5a3561960d1d9a0a581db1208b"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a2fe9fb5a3561960d1d9a0a581db1208b">fbr_buffer_alloc_abort</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer)</td></tr>
<tr class="memdesc:a2fe9fb5a3561960d1d9a0a581db1208b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts a chunk of memory in the buffer.  <a href="#a2fe9fb5a3561960d1d9a0a581db1208b"></a><br/></td></tr>
<tr class="memitem:a108b897c38fd6c2cc88aded63a651e00"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a108b897c38fd6c2cc88aded63a651e00">fbr_buffer_read_address</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer, size_t size)</td></tr>
<tr class="memdesc:a108b897c38fd6c2cc88aded63a651e00"><td class="mdescLeft">&#160;</td><td class="mdescRight">Aborts a chunk of memory in the buffer.  <a href="#a108b897c38fd6c2cc88aded63a651e00"></a><br/></td></tr>
<tr class="memitem:a5c0540906c49f9478313ae4163e992f6"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a5c0540906c49f9478313ae4163e992f6">fbr_buffer_read_advance</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer)</td></tr>
<tr class="memdesc:a5c0540906c49f9478313ae4163e992f6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Confirms a read of chunk of memory in the buffer.  <a href="#a5c0540906c49f9478313ae4163e992f6"></a><br/></td></tr>
<tr class="memitem:a6b46be20587ea69bca6272fa7613a100"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a6b46be20587ea69bca6272fa7613a100">fbr_buffer_read_discard</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer)</td></tr>
<tr class="memdesc:a6b46be20587ea69bca6272fa7613a100"><td class="mdescLeft">&#160;</td><td class="mdescRight">Discards a read of chunk of memory in the buffer.  <a href="#a6b46be20587ea69bca6272fa7613a100"></a><br/></td></tr>
<tr class="memitem:ac9f5342db895cd5c2a847bf565c5271f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#ac9f5342db895cd5c2a847bf565c5271f">fbr_buffer_resize</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *buffer, size_t size)</td></tr>
<tr class="memdesc:ac9f5342db895cd5c2a847bf565c5271f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Resizes the buffer.  <a href="#ac9f5342db895cd5c2a847bf565c5271f"></a><br/></td></tr>
<tr class="memitem:a61c95ede48cd9c6cb157c869eb77da75"><td class="memItemLeft" align="right" valign="top">void *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a61c95ede48cd9c6cb157c869eb77da75">fbr_get_user_data</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> id)</td></tr>
<tr class="memdesc:a61c95ede48cd9c6cb157c869eb77da75"><td class="mdescLeft">&#160;</td><td class="mdescRight">Gets fiber user data pointer.  <a href="#a61c95ede48cd9c6cb157c869eb77da75"></a><br/></td></tr>
<tr class="memitem:a18f052d0f9f909a5da184158fa7e423f"><td class="memItemLeft" align="right" valign="top">int&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="fiber_8h.html#a18f052d0f9f909a5da184158fa7e423f">fbr_set_user_data</a> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> id, void *data)</td></tr>
<tr class="memdesc:a18f052d0f9f909a5da184158fa7e423f"><td class="mdescLeft">&#160;</td><td class="mdescRight">Sets fiber user data pointer.  <a href="#a18f052d0f9f909a5da184158fa7e423f"></a><br/></td></tr>
<tr class="memitem:ac3f252780de38f93ebd45f2f7a732ebb"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac3f252780de38f93ebd45f2f7a732ebb"></a>
pid_t&#160;</td><td class="memItemRight" valign="bottom"><b>fbr_popen3</b> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *filename, char *const argv[], char *const envp[], const char *working_dir, int *stdin_w_ptr, int *stdout_r_ptr, int *stderr_r_ptr)</td></tr>
<tr class="memitem:aef4fc0ddc62be8ab4b9732cc8d5dc843"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="aef4fc0ddc62be8ab4b9732cc8d5dc843"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fbr_waitpid</b> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> pid_t pid)</td></tr>
<tr class="memitem:ac992e07e784df3145b470ddd44a56934"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ac992e07e784df3145b470ddd44a56934"></a>
int&#160;</td><td class="memItemRight" valign="bottom"><b>fbr_system</b> (<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *filename, char *const argv[], char *const envp[], const char *working_dir)</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2><a name="var-members"></a>
Variables</h2></td></tr>
<tr class="memitem:ade51f49aea2360d48299fcc8fc620017"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ade51f49aea2360d48299fcc8fc620017"></a>
uint64_t&#160;</td><td class="memItemRight" valign="bottom"><b>g</b></td></tr>
<tr class="memitem:a117104b82864d3b23ec174af6d392709"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="a117104b82864d3b23ec174af6d392709"></a>
void *&#160;</td><td class="memItemRight" valign="bottom"><b>p</b></td></tr>
<tr class="memitem:ae93b75f3a9a5e358384f8426ea7e122d"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="ae93b75f3a9a5e358384f8426ea7e122d"></a>
const <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td><td class="memItemRight" valign="bottom"><b>FBR_ID_NULL</b></td></tr>
<tr class="memitem:afc4b0504ad11f35479c1863dd5549ac1"><td class="memItemLeft" align="right" valign="top"><a class="anchor" id="afc4b0504ad11f35479c1863dd5549ac1"></a>
enum <a class="el" href="fiber_8h.html#a4b8cb982994caa4c72046dd2970fa5a6">fbr_error_code</a>&#160;</td><td class="memItemRight" valign="bottom"><b>__attribute__</b></td></tr>
</table>
<a name="details" id="details"></a><h2>Detailed Description</h2>
<div class="textblock"><p>This file contains all client-visible API functions for working with fibers. </p>

<p>Definition in file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>
</div><h2>Macro Definition Documentation</h2>
<a class="anchor" id="a2921adccfbd51435ecb82c3780916f57"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fbr_assert</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">context, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">expr&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line"><span class="keywordflow">do</span> {                                                                                  \</div>
<div class="line">                __typeof__(expr) ex = (expr);                                                 \</div>
<div class="line">                if (ex)                                                                       \</div>
<div class="line">                        (<span class="keywordtype">void</span>)(0);                                                            \</div>
<div class="line">                else {                                                                        \</div>
<div class="line">                        fbr_dump_stack(context, <a class="code" href="fiber_8h.html#a1175cd695bd850bfb6d277432e0e7a0c" title="Utility log wrapper.">fbr_log_e</a>);                                   \</div>
<div class="line">                        __assert_fail(__STRING(expr), __FILE__, __LINE__, __ASSERT_FUNCTION); \</div>
<div class="line">                }                                                                             \</div>
<div class="line">        } <span class="keywordflow">while</span> (0)</div>
</div><!-- fragment -->
<p>Fiber version of classic assert. </p>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00169">169</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a4b2672b08a4586b81917b71ef7bc8eee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fbr_container_of</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">member&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">({                       \</div>
<div class="line">                const typeof( ((type *)0)-&gt;member ) *__mptr = (ptr); \</div>
<div class="line">                (type *)( (<span class="keywordtype">char</span> *)__mptr - offsetof(type,member) );  \</div>
<div class="line">                })</div>
</div><!-- fragment -->
<p>Just for convenience we have container_of macro here. </p>
<p>Nothing specific. You can find the same one in the linux kernel tree. </p>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00186">186</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a571e933f126cfccd141927a62fd579a7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define FBR_DESTRUCTOR_INITIALIZER</td>
        </tr>
      </table>
</div><div class="memdoc">
<b>Value:</b><div class="fragment"><div class="line">{ \</div>
<div class="line">        .func   = NULL,              \</div>
<div class="line">        .arg    = NULL,              \</div>
<div class="line">        .active = 0,                 \</div>
<div class="line">};</div>
</div><!-- fragment -->
<p>Definition at line <a class="el" href="fiber_8h_source.html#l00428">428</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="ac5a180f9a74fb4049263f54123501bc0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">#define fbr_ev_upcast</td>
          <td>(</td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">ptr, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname">type_no_struct&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td>&#160;&#160;&#160;<a class="el" href="fiber_8h.html#a4b2672b08a4586b81917b71ef7bc8eee">fbr_container_of</a>(ptr, struct type_no_struct, ev_base)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Convenience macro to save some typing. </p>
<p>Allows you to cast <a class="el" href="structfbr__ev__base.html" title="Base struct for all events.">fbr_ev_base</a> to some other event struct via fbr_container_of magic. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a4b2672b08a4586b81917b71ef7bc8eee" title="Just for convenience we have container_of macro here.">fbr_container_of</a> </dd>
<dd>
<a class="el" href="structfbr__ev__base.html" title="Base struct for all events.">fbr_ev_base</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00472">472</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<h2>Typedef Documentation</h2>
<a class="anchor" id="a68c6e67a55e140618c243d1d1e6d29e7"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbr_alloc_destructor_func_t)(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *ptr, void *context)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(DEPRECATED) Destructor function type for the memory allocated in a fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>memory pointer for memory to be destroyed </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>user data pointer passed via fbr_alloc_set_destructor</td></tr>
  </table>
  </dd>
</dl>
<p>One can attach a destructor to a piece of memory allocated in a fiber. It will be called whenever memory is freed with original pointer allocated along with a user context pointer passed to it. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a3ae27c65ecf583df59641af718d7b854" title="(DEPRECATED) Allocates memory in current fiber&#39;s pool.">fbr_alloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a319b2aba4ccfa51fd1fb8b6ecb6dc90c" title="(DEPRECATED) Explicitly frees allocated memory chunk.">fbr_free</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ac02d87e0172f8765a5caeda2ab33afae" title="(DEPRECATED) Sets destructor for a memory chunk.">fbr_alloc_set_destructor</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00305">305</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a95e135c1ab08d957fcde1e5baf21a43e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbr_destructor_func_t)(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destructor function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>user-defined data argument</td></tr>
  </table>
  </dd>
</dl>
<p>This function gets called when containing fiber dies or destructor is removed with call flag set to 1. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__destructor.html" title="Destructor structure.">fbr_destructor</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00400">400</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a7b11ce8e4d8a3cdfe9e7ea43598761b2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbr_fiber_func_t)(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *_arg)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber's ``main'' function type. </p>
<p>Fiber main function takes only one parameter &mdash; the context. If you need to pass more context information, you shall embed <a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> into any structure of your choice and calculate the base pointer using container_of macro. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914" title="Utility macro for context parameter used in function prototypes.">FBR_P</a> </dd>
<dd>
<a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00291">291</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="ad08a37907434cf705119847ed590a089"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef struct <a class="el" href="structfbr__id__s.html">fbr_id_s</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber ID type. </p>
<p>For you it's just an opaque type. </p>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00203">203</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a6a327243ec5baeb5b3145c6624d0977c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef unsigned int <a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber-local data key. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a9fe6e2b8e563ba4952b0a70897303d53" title="Fiber-local key creation.">fbr_key_create</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a2adf94a9da3b680795a8d900526f7959" title="Fiber-local key deletion.">fbr_key_delete</a> </dd>
<dd>
fbr_key_get_data </dd>
<dd>
fbr_key_set_data </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00587">587</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="abcc45eba652c34b021a4dceddc485135"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbr_log_func_t)(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__logger.html">fbr_logger</a> *logger, enum <a class="el" href="fiber_8h.html#a5d63a523db6c2493dc2b650dcbed9be3">fbr_log_level</a> level, const char *format, va_list ap)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logger function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">logger</td><td>currently configured logger </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">level</td><td>log level of message </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>printf-compatible format string </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">ap</td><td>variadic argument list This function should log the message if log level suits the one configured in a non-blocking manner (i.e. it should not synchronously write it to disk). </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00334">334</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a0a1d0579fe89b13fab05a3ad54e61188"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">typedef void(* fbr_logutil_func_t)(<a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *format,...)</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logger utility function type. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">format</td><td>printf-compatible format string</td></tr>
  </table>
  </dd>
</dl>
<p>This function wraps logger function invocation. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00345">345</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<h2>Enumeration Type Documentation</h2>
<a class="anchor" id="a4b8cb982994caa4c72046dd2970fa5a6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="fiber_8h.html#a4b8cb982994caa4c72046dd2970fa5a6">fbr_error_code</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Error codes used within the library. </p>
<p>These constants are returned via f_errno member of <a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> struct. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a490cd2689aedc1ca0e60404a47b7f550" title="Analog of strerror but for the library errno.">fbr_strerror</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00224">224</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a61e29a575eecbcfef017b66bee4409ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="fiber_8h.html#a61e29a575eecbcfef017b66bee4409ee">fbr_ev_type</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Type of events supported by the library. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a66566b61e09d8cb20908f952f319a2cf" title="Event awaiting function (generic one).">fbr_ev_wait</a> </dd></dl>
<dl><dt><b>Enumerator: </b></dt><dd><table border="0" cellspacing="2" cellpadding="0">
<tr><td valign="top"><em><a class="anchor" id="a61e29a575eecbcfef017b66bee4409eea6a6285430da9ea418e18093929066d35"></a>FBR_EV_WATCHER</em>&nbsp;</td><td>
<p>libev watcher event </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a61e29a575eecbcfef017b66bee4409eea200a3dc22cf18bfbcc9fe1201c2198a5"></a>FBR_EV_MUTEX</em>&nbsp;</td><td>
<p><a class="el" href="structfbr__mutex.html" title="Mutex structure.">fbr_mutex</a> event </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a61e29a575eecbcfef017b66bee4409eeaf1250fc8e958238e6347f1373623224f"></a>FBR_EV_COND_VAR</em>&nbsp;</td><td>
<p><a class="el" href="structfbr__cond__var.html" title="Conditional variable structure.">fbr_cond_var</a> event </p>
</td></tr>
<tr><td valign="top"><em><a class="anchor" id="a61e29a575eecbcfef017b66bee4409eea0854994f9f2dfe14081bb798ca503516"></a>FBR_EV_EIO</em>&nbsp;</td><td>
<p>libeio event </p>
</td></tr>
</table>
</dd>
</dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00382">382</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<a class="anchor" id="a5d63a523db6c2493dc2b650dcbed9be3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="fiber_8h.html#a5d63a523db6c2493dc2b650dcbed9be3">fbr_log_level</a></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Logging levels. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8h_source.html#l00312">312</a> of file <a class="el" href="fiber_8h_source.html">fiber.h</a>.</p>

</div>
</div>
<h2>Function Documentation</h2>
<a class="anchor" id="a3faee7c5804a20b08b77aa43eb29f69c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_accept </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly libc accept wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sockfd</td><td>file descriptor to accept on </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>client address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>size of addr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>client socket fd on success, -1 in case of error and errno set</dd></dl>
<p>This function is used to accept a connection on a listening socket.</p>
<p>Possible errno values are described in accept man page. The only special case is EINTR which is handled internally and is returned to the caller only in case when non-root fiber called the fiber sitting in fbr_accept. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01113">1113</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3ae27c65ecf583df59641af718d7b854"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbr_alloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> size_t&#160;</td>
          <td class="paramname"><em>size</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(DEPRECATED) Allocates memory in current fiber's pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of the requested memory block </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>allocated memory chunk</dd></dl>
<p>When a fiber is reclaimed, this memory will be freed. Prior to that a destructor will be called if any specified. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#ab5d442e97e9f8d321ad564ed1351fc56" title="(DEPRECATED) Allocates a set of initialized objects in fiber&#39;s pool.">fbr_calloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ac02d87e0172f8765a5caeda2ab33afae" title="(DEPRECATED) Sets destructor for a memory chunk.">fbr_alloc_set_destructor</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a68c6e67a55e140618c243d1d1e6d29e7" title="(DEPRECATED) Destructor function type for the memory allocated in a fiber.">fbr_alloc_destructor_func_t</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a319b2aba4ccfa51fd1fb8b6ecb6dc90c" title="(DEPRECATED) Explicitly frees allocated memory chunk.">fbr_free</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01248">1248</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac02d87e0172f8765a5caeda2ab33afae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_alloc_set_destructor </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *&#160;</td>
          <td class="paramname"><em>ptr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a68c6e67a55e140618c243d1d1e6d29e7">fbr_alloc_destructor_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>context</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(DEPRECATED) Sets destructor for a memory chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>address of a memory chunk </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>destructor function </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">context</td><td>user supplied context pointer</td></tr>
  </table>
  </dd>
</dl>
<p>Setting new destructor simply changes it without calling old one or queueing them.</p>
<p>You can allocate 0 sized memory chunk and never free it just for the purpose of calling destructor with some context when fiber is reclaimed. This way you can for example close some file descriptors or do some other required cleanup. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a3ae27c65ecf583df59641af718d7b854" title="(DEPRECATED) Allocates memory in current fiber&#39;s pool.">fbr_alloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a319b2aba4ccfa51fd1fb8b6ecb6dc90c" title="(DEPRECATED) Explicitly frees allocated memory chunk.">fbr_free</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a2fe9fb5a3561960d1d9a0a581db1208b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_buffer_alloc_abort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts a chunk of memory in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function aborts prepared chunk of memory previously reserved. It will not be committed and the next fiber may reuse it for it's own purposes. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#aa42cff2b51a686cf8c709eab00dcd2d3" title="Prepares a chunk of memory to be committed to buffer.">fbr_buffer_alloc_prepare</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a13f334f3b42aebcce64fbbd6f353eeae" title="Commits a chunk of memory to the buffer.">fbr_buffer_alloc_commit</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01592">1592</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a13f334f3b42aebcce64fbbd6f353eeae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_buffer_alloc_commit </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Commits a chunk of memory to the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function commits a chunk of memory previously reserved. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#aa42cff2b51a686cf8c709eab00dcd2d3" title="Prepares a chunk of memory to be committed to buffer.">fbr_buffer_alloc_prepare</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a2fe9fb5a3561960d1d9a0a581db1208b" title="Aborts a chunk of memory in the buffer.">fbr_buffer_alloc_abort</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01584">1584</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="aa42cff2b51a686cf8c709eab00dcd2d3"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbr_buffer_alloc_prepare </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prepares a chunk of memory to be committed to buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>required size </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to memory reserved for commit.</dd></dl>
<p>This function reserves a chunk of memory (or waits until there is one available, blocking current fiber) and returns pointer to it.</p>
<p>A fiber trying to reserve a chunk of memory after some other fiber already reserved it leads to the former fiber being blocked until the latter one commits or aborts. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a13f334f3b42aebcce64fbbd6f353eeae" title="Commits a chunk of memory to the buffer.">fbr_buffer_alloc_commit</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a2fe9fb5a3561960d1d9a0a581db1208b" title="Aborts a chunk of memory in the buffer.">fbr_buffer_alloc_abort</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01562">1562</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9bcb12effba786b481727451f8fee279"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_buffer_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a circular buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a> to free</td></tr>
  </table>
  </dd>
</dl>
<p>This unmaps all mmaped memory for the buffer. It does not do any fancy stuff like waiting until buffer is empty etc., it just frees it. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01552">1552</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="addee07a0306f1962c3d48b8a3a75221c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_buffer_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a circular buffer with pipe semantics. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td><a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a> structure to initialize </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size hint for the buffer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 upon failure with f_errno set.</dd></dl>
<p>This allocates a buffer with pipe semantics: you can write into it and later read what you have written. The buffer will occupy size rounded up to page size in physical memory, while occupying twice this size in virtual process memory due to usage of two mirrored adjacent mmaps. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01529">1529</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a108b897c38fd6c2cc88aded63a651e00"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbr_buffer_read_address </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Aborts a chunk of memory in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>number of bytes required </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>read address containing size bytes</dd></dl>
<p>This function reserves (or waits till data is available, blocking current fiber) a chunk of memory for reading. While a chunk of memory is reserved for reading no other fiber can read from this buffer blocking until current read is advanced or discarded. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a5c0540906c49f9478313ae4163e992f6" title="Confirms a read of chunk of memory in the buffer.">fbr_buffer_read_advance</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a6b46be20587ea69bca6272fa7613a100" title="Discards a read of chunk of memory in the buffer.">fbr_buffer_read_discard</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01599">1599</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5c0540906c49f9478313ae4163e992f6"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_buffer_read_advance </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Confirms a read of chunk of memory in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function confirms that bytes obtained with fbr_buffer_read_address are read and no other fiber will be able to read them. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a108b897c38fd6c2cc88aded63a651e00" title="Aborts a chunk of memory in the buffer.">fbr_buffer_read_address</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a6b46be20587ea69bca6272fa7613a100" title="Discards a read of chunk of memory in the buffer.">fbr_buffer_read_discard</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01619">1619</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6b46be20587ea69bca6272fa7613a100"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_buffer_read_discard </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Discards a read of chunk of memory in the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function discards bytes obtained with fbr_buffer_read_address. Next fiber trying to read something from a buffer may obtain those bytes. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a108b897c38fd6c2cc88aded63a651e00" title="Aborts a chunk of memory in the buffer.">fbr_buffer_read_address</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a5c0540906c49f9478313ae4163e992f6" title="Confirms a read of chunk of memory in the buffer.">fbr_buffer_read_advance</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01627">1627</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac9f5342db895cd5c2a847bf565c5271f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_buffer_resize </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__buffer.html">fbr_buffer</a> *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Resizes the buffer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>a pointer to <a class="el" href="structfbr__buffer.html" title="Inter-fiber communication pipe.">fbr_buffer</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>a new buffer length </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<p>This function allocates new memory mapping of sufficient size and copies the content of a buffer into it. Old mapping is destroyed.</p>
<p>This operation is expensive and involves several syscalls, so it is beneficiary to allocate a buffer of siffucuent size from the start.</p>
<p>This function acquires both read and write mutex, and may block until read or write operation has finished. </p>
<dl class="section see"><dt>See Also</dt><dd>fbr_buffer_reset </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01632">1632</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab5d442e97e9f8d321ad564ed1351fc56"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbr_calloc </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> unsigned int&#160;</td>
          <td class="paramname"><em>nmemb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(DEPRECATED) Allocates a set of initialized objects in fiber's pool. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">nmemb</td><td>number of members </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>size of a single member </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero-filled allocated memory chunk</dd></dl>
<p>Same as fbr_alloc called with nmemb multiplied by size. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a3ae27c65ecf583df59641af718d7b854" title="(DEPRECATED) Allocates memory in current fiber&#39;s pool.">fbr_alloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a319b2aba4ccfa51fd1fb8b6ecb6dc90c" title="(DEPRECATED) Explicitly frees allocated memory chunk.">fbr_free</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01239">1239</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a311a4af921fa667d7c85fa0ea25e4206"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_cond_broadcast </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Broadcasts a signal to all fibers waiting for condition. </p>
<p>All fibers waiting for a condition will be added to run queue (and will eventually be run, one per event loop iteration).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a7ce468de0b1706afe9a3635302418705" title="Initializes a conditional variable.">fbr_cond_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a1a852b3dc4dd0c187845618843d1aea2" title="Destroys a conditional variable.">fbr_cond_destroy</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a7d7705e044c32657c1ea5e85f246db4f" title="Waits until condition is met.">fbr_cond_wait</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#aa48cc22cabc0aa4f8426ac566cf93eed" title="Signals to first fiber waiting for a condition.">fbr_cond_signal</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01418">1418</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a1a852b3dc4dd0c187845618843d1aea2"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_cond_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a conditional variable. </p>
<p>This just frees used resources. No signals are sent to waiting fibers.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a7ce468de0b1706afe9a3635302418705" title="Initializes a conditional variable.">fbr_cond_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a7d7705e044c32657c1ea5e85f246db4f" title="Waits until condition is met.">fbr_cond_wait</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a311a4af921fa667d7c85fa0ea25e4206" title="Broadcasts a signal to all fibers waiting for condition.">fbr_cond_broadcast</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#aa48cc22cabc0aa4f8426ac566cf93eed" title="Signals to first fiber waiting for a condition.">fbr_cond_signal</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a7ce468de0b1706afe9a3635302418705"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_cond_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a conditional variable. </p>
<p>Conditional variable is useful primitive for fiber synchronisation. A set of fibers may be waiting until certain condition is met. Another fiber can trigger this condition for one or all waiting fibers.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a1a852b3dc4dd0c187845618843d1aea2" title="Destroys a conditional variable.">fbr_cond_destroy</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a7d7705e044c32657c1ea5e85f246db4f" title="Waits until condition is met.">fbr_cond_wait</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a311a4af921fa667d7c85fa0ea25e4206" title="Broadcasts a signal to all fibers waiting for condition.">fbr_cond_broadcast</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#aa48cc22cabc0aa4f8426ac566cf93eed" title="Signals to first fiber waiting for a condition.">fbr_cond_signal</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa48cc22cabc0aa4f8426ac566cf93eed"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_cond_signal </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *&#160;</td>
          <td class="paramname"><em>cond</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Signals to first fiber waiting for a condition. </p>
<p>Exactly one fiber (first one) waiting for a condition will be added to run queue (and will eventually be run, one per event loop iteration).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a7ce468de0b1706afe9a3635302418705" title="Initializes a conditional variable.">fbr_cond_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a1a852b3dc4dd0c187845618843d1aea2" title="Destroys a conditional variable.">fbr_cond_destroy</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a7d7705e044c32657c1ea5e85f246db4f" title="Waits until condition is met.">fbr_cond_wait</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#aa48cc22cabc0aa4f8426ac566cf93eed" title="Signals to first fiber waiting for a condition.">fbr_cond_signal</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01434">1434</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7d7705e044c32657c1ea5e85f246db4f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_cond_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Waits until condition is met. </p>
<p>Current fiber is suspended until a signal is sent via fbr_cond_signal or fbr_cond_broadcast to the corresponding conditional variable.</p>
<p>A mutex must be acquired by the calling fiber prior to waiting for a condition. Internally mutex is released and reacquired again before returning. Upon successful return calling fiber will hold the mutex.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a7ce468de0b1706afe9a3635302418705" title="Initializes a conditional variable.">fbr_cond_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a1a852b3dc4dd0c187845618843d1aea2" title="Destroys a conditional variable.">fbr_cond_destroy</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a311a4af921fa667d7c85fa0ea25e4206" title="Broadcasts a signal to all fibers waiting for condition.">fbr_cond_broadcast</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#aa48cc22cabc0aa4f8426ac566cf93eed" title="Signals to first fiber waiting for a condition.">fbr_cond_signal</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01406">1406</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3abd87ac5934036fd81c762fc2d7af69"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_connect </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly connect wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sockfd</td><td>- socket file descriptor </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addr</td><td>- pointer to struct sockaddr, containing connection details </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">length</td><td>of struct sockaddr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>zero on success, -1 in case of error and errno set</dd></dl>
<p>Connect wrapper, that connects the socket referred to by the file descriptor sockfd to the address specified by addr. starting at buf. Calling fiber will be blocked until sockfd is connected or error is occured</p>
<p>Possible errno values are described in connect man page. The only special case is EINPROGRESS which is handled internally. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00807">807</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a9d7bedaf3d6d32f2ed0b2f400a5970a5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_cooperate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields execution to other fiber returning the execution at the next event loop run. </p>
<p>Useful inside of some busy loop with lots of iterations to play nicely with other fibers which might start starving on the execution time. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#aac7f380431691642e6ef83962fb77ea1" title="Yields execution to other fiber.">fbr_yield</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a0e6f58c891a8cbf336bdd677314e535c" title="Transfer of fiber context to another fiber.">fbr_transfer</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a9b28e140133bb8af4fe33053f2c5285b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fbr_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *&#160;</td>
          <td class="paramname"><em>name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a7b11ce8e4d8a3cdfe9e7ea43598761b2">fbr_fiber_func_t</a>&#160;</td>
          <td class="paramname"><em>func</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>arg</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>stack_size</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>fiber name, used for identification it backtraces, etc. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">func</td><td>function used as a fiber's ``main''. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">stack_size</td><td>stack size (0 for default). </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">arg</td><td>user supplied argument to a fiber. </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Pointer to the created fiber.</dd></dl>
<p>The created fiber is not running in any shape or form, it's just created and is ready to be launched.</p>
<p>Stack is anonymously mmaped so it should not occupy all the required space straight away. Adjust stack size only when you know what you are doing!</p>
<p>Allocated stacks are registered as stacks via valgrind client request mechanism, so it's generally valgrind friendly and should not cause any noise.</p>
<p>Fibers are organized in a tree. Child nodes are attached to a parent whenever the parent is creating them. This tree is used primarily for automatic reclaim of child fibers. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a55e114145e071051ae58315dc4de5702" title="Reclaims a fiber.">fbr_reclaim</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4b42ab908f71c52ce8c64cefd38c50ee" title="Changes parent of current fiber.">fbr_disown</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a558d2d2ccef531e2c8759388d38658aa" title="Find out current fiber&#39;s parent.">fbr_parent</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01179">1179</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae2d252e157ba838c56dbe4ab5b061e7f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys the library context. </p>
<p>All created fibers are reclaimed and all of the memory is freed. Stopping the event loop is user's responsibility. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a5aae42537a1db369f308cba59985b662" title="Initializes the library context.">fbr_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a55e114145e071051ae58315dc4de5702" title="Reclaims a fiber.">fbr_reclaim</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00321">321</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac459666cfb5bf34e4dd651f343f8783e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_destructor_add </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__destructor.html">fbr_destructor</a> *&#160;</td>
          <td class="paramname"><em>dtor</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Adds destructor to fiber list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dtor</td><td>destructor to register</td></tr>
  </table>
  </dd>
</dl>
<p>This function registers a destructor. User must guarantee that destructor object stays alive until fiber is reclaimed or destructor is removed, whichever comes first. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__destructor.html" title="Destructor structure.">fbr_destructor</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01660">1660</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a0d67f581b2398fac8bfc0a35af698ad4"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_destructor_remove </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__destructor.html">fbr_destructor</a> *&#160;</td>
          <td class="paramname"><em>dtor</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>call</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Removes destructor from fiber list. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">dtor</td><td>destructor to unregister </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">call</td><td>flag indicating if destructor needs to be called</td></tr>
  </table>
  </dd>
</dl>
<p>This function unregisters a destructor. User may specify a flag for destructor function to be called. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__destructor.html" title="Destructor structure.">fbr_destructor</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01667">1667</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4b42ab908f71c52ce8c64cefd38c50ee"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_disown </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>parent</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Changes parent of current fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">parent</td><td>new parent fiber </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error with f_errno set, 0 upon success</dd></dl>
<p>This function allows you to change fiber's parent. You needs to pass valid id or 0 to indicate the root fiber.</p>
<p>This might be useful when some fiber A creates another fiber B that should survive it's parent being reclaimed, or vice versa, some fiber A needs to be reclaimed with fiber B albeit B is not A's parent.</p>
<p>Root fiber is reclaimed only when library context is destroyed. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a9b28e140133bb8af4fe33053f2c5285b" title="Creates a new fiber.">fbr_create</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ae2d252e157ba838c56dbe4ab5b061e7f" title="Destroys the library context.">fbr_destroy</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01217">1217</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a3b6b21326ccf1a23fd96c11c4b9b3b81"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_dump_stack </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188">fbr_logutil_func_t</a>&#160;</td>
          <td class="paramname"><em>log</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Prints fiber call stack to stderr. </p>
<p>useful while debugging obscure fiber call problems. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01277">1277</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad4632e5653fe6aed586b9dfd23716708"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_enable_backtraces </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>enabled</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Enables/Disables backtrace capturing. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">enabled</td><td>are backtraces enabled?</td></tr>
  </table>
  </dd>
</dl>
<p>The library tries to capture backtraces at certain points which may help when debugging obscure problems. For example it captures the backtrace whenever a fiber is reclaimed and when one tries to call it dumps out the backtrace showing where was it reclaimed. But these cost quite a bit of cpu and are disabled by default. </p>

</div>
</div>
<a class="anchor" id="a5a246c700c9fed3bf8d5ef049156eaae"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_ev_cond_var_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__cond__var.html">fbr_ev_cond_var</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfbr__cond__var.html">fbr_cond_var</a> *&#160;</td>
          <td class="paramname"><em>cond</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for conditional variable event. </p>
<p>This functions properly initializes <a class="el" href="structfbr__ev__cond__var.html" title="fbr_cond_var event.">fbr_ev_cond_var</a> struct. You should not do it manually. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__ev__cond__var.html" title="fbr_cond_var event.">fbr_ev_cond_var</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a66566b61e09d8cb20908f952f319a2cf" title="Event awaiting function (generic one).">fbr_ev_wait</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01385">1385</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="aed73b4ac7962689d4518f9a8ce88d290"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_ev_mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__mutex.html">fbr_ev_mutex</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for mutex event. </p>
<p>This functions properly initializes <a class="el" href="structfbr__ev__mutex.html" title="fbr_mutex event.">fbr_ev_mutex</a> struct. You should not do it manually. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__ev__mutex.html" title="fbr_mutex event.">fbr_ev_mutex</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a66566b61e09d8cb20908f952f319a2cf" title="Event awaiting function (generic one).">fbr_ev_wait</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01319">1319</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a66566b61e09d8cb20908f952f319a2cf"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_ev_wait </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__base.html">fbr_ev_base</a> *&#160;</td>
          <td class="paramname"><em>events</em>[]</td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event awaiting function (generic one). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>array of event base pointers </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events arrived or -1 upon error</dd></dl>
<p>This function waits until any event from events array arrives. Only one event can arrive at a time. It returns a pointer to the same event that was passed in events array. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__ev__base.html" title="Base struct for all events.">fbr_ev_base</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a8b2ecf950d76464077b2d4e39036eb47" title="Event awaiting function (one event only wrapper).">fbr_ev_wait_one</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00678">678</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8b2ecf950d76464077b2d4e39036eb47"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_ev_wait_one </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__base.html">fbr_ev_base</a> *&#160;</td>
          <td class="paramname"><em>one</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event awaiting function (one event only wrapper). </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">one</td><td>the event base pointer of the event to wait for </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 upon error</dd></dl>
<p>This functions wraps fbr_ev_wait passing only one event to it. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__ev__base.html" title="Base struct for all events.">fbr_ev_base</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a66566b61e09d8cb20908f952f319a2cf" title="Event awaiting function (generic one).">fbr_ev_wait</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00715">715</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a845bb0c84adde64be31c8a3c3b0c5f2e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_ev_wait_to </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__base.html">fbr_ev_base</a> *&#160;</td>
          <td class="paramname"><em>events</em>[], </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_tstamp&#160;</td>
          <td class="paramname"><em>timeout</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Event awaiting function with timeout. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">events</td><td>array of event base pointers </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">timeout</td><td>in seconds to wait for the events </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>the number of events arrived or -1 upon error</dd></dl>
<p>This function is a convenient wrapper around fbr_ev_wait, it just creates a timer watcher and makes new events array with the timer watcher included. Timer event is not counted in the number of returned events. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a66566b61e09d8cb20908f952f319a2cf" title="Event awaiting function (generic one).">fbr_ev_wait</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00645">645</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8f7c8a5bfe2a9b6e24ec0bcce50e6617"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_ev_watcher_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__ev__watcher.html">fbr_ev_watcher</a> *&#160;</td>
          <td class="paramname"><em>ev</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">ev_watcher *&#160;</td>
          <td class="paramname"><em>w</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializer for libev watcher event. </p>
<p>This functions properly initializes <a class="el" href="structfbr__ev__watcher.html" title="libev watcher event.">fbr_ev_watcher</a> struct. You should not do it manually. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__ev__watcher.html" title="libev watcher event.">fbr_ev_watcher</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a66566b61e09d8cb20908f952f319a2cf" title="Event awaiting function (generic one).">fbr_ev_wait</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00795">795</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6d9713d1024c384f4fd2ac9bbf1df760"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_fd_nonblock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>fd</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to make file descriptor non-blocking. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to make non-blocking </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error with f_errno set, 0 upon success</dd></dl>
<p>In case of failure FBR_ESYSTEM is set as f_errno ans user should consult system errno for details. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00770">770</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a319b2aba4ccfa51fd1fb8b6ecb6dc90c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_free </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(DEPRECATED) Explicitly frees allocated memory chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>chunk address</td></tr>
  </table>
  </dd>
</dl>
<p>Explicitly frees a fiber pool chunk calling the destructor if any. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a3ae27c65ecf583df59641af718d7b854" title="(DEPRECATED) Allocates memory in current fiber&#39;s pool.">fbr_alloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ab5d442e97e9f8d321ad564ed1351fc56" title="(DEPRECATED) Allocates a set of initialized objects in fiber&#39;s pool.">fbr_calloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ac02d87e0172f8765a5caeda2ab33afae" title="(DEPRECATED) Sets destructor for a memory chunk.">fbr_alloc_set_destructor</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01265">1265</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8a685149a3574f43a1e2ca064ddcf09d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_free_nd </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> void *&#160;</td>
          <td class="paramname"><em>ptr</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>(DEPRECATED) Explicitly frees allocated memory chunk. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">ptr</td><td>chunk address</td></tr>
  </table>
  </dd>
</dl>
<p>Explicitly frees a fiber pool chunk without calling the destructor. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a3ae27c65ecf583df59641af718d7b854" title="(DEPRECATED) Allocates memory in current fiber&#39;s pool.">fbr_alloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ab5d442e97e9f8d321ad564ed1351fc56" title="(DEPRECATED) Allocates a set of initialized objects in fiber&#39;s pool.">fbr_calloc</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ac02d87e0172f8765a5caeda2ab33afae" title="(DEPRECATED) Sets destructor for a memory chunk.">fbr_alloc_set_destructor</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01271">1271</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a8ca58482ab7f2386cee302b51f58ef2b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fbr_get_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Retrieve a name of the fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identificator of a fiber </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>pointer to charater buffer or NULL on error</dd></dl>
<p>The name is located in the statically allocated buffer of size FBR_MAX_FIBER_NAME.</p>
<p>Don't try to free it!</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a9b28e140133bb8af4fe33053f2c5285b" title="Creates a new fiber.">fbr_create</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ade47de6332577b83545d4e424ab1c5d1" title="Sets a name for the fiber.">fbr_set_name</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01746">1746</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a61c95ede48cd9c6cb157c869eb77da75"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbr_get_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets fiber user data pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>fiber id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>user data pointer on success, NULL on failure with f_errno set</dd></dl>
<p>This function allows you to retrieve user data pointer. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a18f052d0f9f909a5da184158fa7e423f" title="Sets fiber user data pointer.">fbr_set_user_data</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01645">1645</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a5aae42537a1db369f308cba59985b662"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfbr__context.html">fbr_context</a> *&#160;</td>
          <td class="paramname"><em>fctx</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct ev_loop *&#160;</td>
          <td class="paramname"><em>loop</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes the library context. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fctx</td><td>pointer to the user allocated <a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a>. </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">loop</td><td>pointer to the user supplied libev loop.</td></tr>
  </table>
  </dd>
</dl>
<p>It's user's responsibility to allocate <a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> structure and create and run the libev event loop. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ae2d252e157ba838c56dbe4ab5b061e7f" title="Destroys the library context.">fbr_destroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a1228e6d3c768a4b91f265de750c14a"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_is_reclaimed </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tests if given fiber is reclaimed. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td>fiber pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if fiber is reclaimed, 0 otherwise </dd></dl>

</div>
</div>
<a class="anchor" id="a9fe6e2b8e563ba4952b0a70897303d53"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_key_create </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a> *&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber-local key creation. </p>
<p>This created a new unique key and stores it in key. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01702">1702</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a2adf94a9da3b680795a8d900526f7959"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_key_delete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber-local key deletion. </p>
<p>This explicitly destroys a key. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01711">1711</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="af8ba856b12a7d5d82bec65d959484e46"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void* fbr_key_get </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Gets fiber-local key data. </p>
<p>This retrieves the value under a key. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01734">1734</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a25c57588776af549c18e68c5022a8a5e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_key_set </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a6a327243ec5baeb5b3145c6624d0977c">fbr_key_t</a>&#160;</td>
          <td class="paramname"><em>key</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>value</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets fiber-local key data. </p>
<p>This stores a value under a key. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01721">1721</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad72c35cd4b120be1c6e97c45f50dc6dc"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void void fbr_log_d </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility log wrapper. </p>
<p>Wraps logv function of type fbr_log_func_t located in <a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> with log level of FBR_LOG_DEBUG. Follows printf semantics of format string and variadic argument list. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188" title="Logger utility function type.">fbr_logutil_func_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a1175cd695bd850bfb6d277432e0e7a0c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_log_e </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility log wrapper. </p>
<p>Wraps logv function of type fbr_log_func_t located in <a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> with log level of FBR_LOG_ERROR. Follows printf semantics of format string and variadic argument list. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188" title="Logger utility function type.">fbr_logutil_func_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="aa815bc8cf6b125b76e852a41dd488812"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void void fbr_log_i </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility log wrapper. </p>
<p>Wraps logv function of type fbr_log_func_t located in <a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> with log level of FBR_LOG_INFO. Follows printf semantics of format string and variadic argument list. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188" title="Logger utility function type.">fbr_logutil_func_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="ae2bf0d14636801edb0d66dc388a2616f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void void fbr_log_n </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility log wrapper. </p>
<p>Wraps logv function of type fbr_log_func_t located in <a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> with log level of FBR_LOG_NOTICE. Follows printf semantics of format string and variadic argument list. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188" title="Logger utility function type.">fbr_logutil_func_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5a69c39229c1d71f9391682e994c1ed0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void void fbr_log_w </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> const char *&#160;</td>
          <td class="paramname"><em>format</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">&#160;</td>
          <td class="paramname"><em>...</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility log wrapper. </p>
<p>Wraps logv function of type fbr_log_func_t located in <a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> with log level of FBR_LOG_WARNING. Follows printf semantics of format string and variadic argument list. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="structfbr__logger.html" title="Logger structure.">fbr_logger</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#abcc45eba652c34b021a4dceddc485135" title="Logger function type.">fbr_log_func_t</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a0a1d0579fe89b13fab05a3ad54e61188" title="Logger utility function type.">fbr_logutil_func_t</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a8dce5f86a2fbcbd59863ddb7dd882ec5"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_mutex_destroy </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>pointer to mutex</td></tr>
  </table>
  </dd>
</dl>
<p>Frees used resources. It does not unlock the mutex.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a5cb28512c5d778bb621fdf3e633fa461" title="Initializes a mutex.">fbr_mutex_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a469e97dc647b4d362806ddbafacd9fea" title="Locks a mutex.">fbr_mutex_lock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4a0d3e801f81b9d0d2d12a161f2aa134" title="Unlocks a mutex.">fbr_mutex_unlock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4e384456743a5e0a5c00d23463726681" title="Tries to locks a mutex.">fbr_mutex_trylock</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a5cb28512c5d778bb621fdf3e633fa461"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_mutex_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>a mutex structure to initialize</td></tr>
  </table>
  </dd>
</dl>
<p>Mutexes are helpful when your fiber has a critical code section including several fbr_* calls. In this case execution of multiple copies of your fiber may get mixed up.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a469e97dc647b4d362806ddbafacd9fea" title="Locks a mutex.">fbr_mutex_lock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4e384456743a5e0a5c00d23463726681" title="Tries to locks a mutex.">fbr_mutex_trylock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4a0d3e801f81b9d0d2d12a161f2aa134" title="Unlocks a mutex.">fbr_mutex_unlock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a8dce5f86a2fbcbd59863ddb7dd882ec5" title="Destroys a mutex.">fbr_mutex_destroy</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a469e97dc647b4d362806ddbafacd9fea"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_mutex_lock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Locks a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>pointer to a mutex</td></tr>
  </table>
  </dd>
</dl>
<p>Attempts to lock a mutex. If mutex is already locked then the calling fiber is suspended until the mutex is eventually freed.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a5cb28512c5d778bb621fdf3e633fa461" title="Initializes a mutex.">fbr_mutex_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4e384456743a5e0a5c00d23463726681" title="Tries to locks a mutex.">fbr_mutex_trylock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4a0d3e801f81b9d0d2d12a161f2aa134" title="Unlocks a mutex.">fbr_mutex_unlock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a8dce5f86a2fbcbd59863ddb7dd882ec5" title="Destroys a mutex.">fbr_mutex_destroy</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01332">1332</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4e384456743a5e0a5c00d23463726681"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_mutex_trylock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Tries to locks a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>pointer to a mutex </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>1 if lock was successful, 0 otherwise</dd></dl>
<p>Attempts to lock a mutex. Returns immediately despite of locking being successful or not.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a5cb28512c5d778bb621fdf3e633fa461" title="Initializes a mutex.">fbr_mutex_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a469e97dc647b4d362806ddbafacd9fea" title="Locks a mutex.">fbr_mutex_lock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4a0d3e801f81b9d0d2d12a161f2aa134" title="Unlocks a mutex.">fbr_mutex_unlock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a8dce5f86a2fbcbd59863ddb7dd882ec5" title="Destroys a mutex.">fbr_mutex_destroy</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01341">1341</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4a0d3e801f81b9d0d2d12a161f2aa134"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_mutex_unlock </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> struct <a class="el" href="structfbr__mutex.html">fbr_mutex</a> *&#160;</td>
          <td class="paramname"><em>mutex</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Unlocks a mutex. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">mutex</td><td>pointer to a mutex</td></tr>
  </table>
  </dd>
</dl>
<p>Unlocks the given mutex. An other fiber that is waiting for it (if any) will be called upon next libev loop iteration.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a5cb28512c5d778bb621fdf3e633fa461" title="Initializes a mutex.">fbr_mutex_init</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a469e97dc647b4d362806ddbafacd9fea" title="Locks a mutex.">fbr_mutex_lock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4e384456743a5e0a5c00d23463726681" title="Tries to locks a mutex.">fbr_mutex_trylock</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a8dce5f86a2fbcbd59863ddb7dd882ec5" title="Destroys a mutex.">fbr_mutex_destroy</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01350">1350</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a558d2d2ccef531e2c8759388d38658aa"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fbr_parent </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Find out current fiber's parent. </p>
<dl class="section return"><dt>Returns</dt><dd>current fiber's parent</dd></dl>
<p>This function allows you to find out what fiber is considered to be parent for the current one. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a9b28e140133bb8af4fe33053f2c5285b" title="Creates a new fiber.">fbr_create</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4b42ab908f71c52ce8c64cefd38c50ee" title="Changes parent of current fiber.">fbr_disown</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01231">1231</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a6b13f824e8810e439fe5356d021eb8a0"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_read </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly libc read wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>maximum number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success, -1 in case of error and errno set</dd></dl>
<p>Attempts to read up to count bytes from file descriptor fd into the buffer starting at buf. Calling fiber will be blocked until something arrives at fd.</p>
<p>Possible errno values are described in read man page. The only special case is EINTR which is handled internally and is returned to the caller only in case when non-root fiber called the fiber waiting in fbr_read.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#ad83bfc4ecfcab4d968e599be39b7d4df" title="Even more fiber friendly libc read wrapper.">fbr_read_all</a> </dd>
<dd>
fbr_read_line </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00839">839</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad83bfc4ecfcab4d968e599be39b7d4df"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_read_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Even more fiber friendly libc read wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>desired number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success, -1 in case of error and errno set</dd></dl>
<p>Attempts to read exactly count bytes from file descriptor fd into the buffer starting at buf. Calling fiber will be blocked until the required amount of data or EOF arrive at fd. If latter occurs too early returned number of bytes will be less that required.</p>
<p>Possible errno values are described in read man page. Unlike fbr_read this function will never return -1 with EINTR and will silently ignore any attempts to call this fiber from other non-root fibers (call infos are still queued if the called desired to do so).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a6b13f824e8810e439fe5356d021eb8a0" title="Fiber friendly libc read wrapper.">fbr_read</a> </dd>
<dd>
fbr_read_line </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00865">865</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a7610e6294cd13295352a26293ebb1cef"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_readline </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buffer</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>n</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Utility function to read a line. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buffer</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">n</td><td>maximum number of bytes to read </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success, -1 in case of error and errno set</dd></dl>
<p>Attempts to read at most count bytes from file descriptor fd into the buffer starting at buf, but stops if newline is encountered. Calling fiber will be blocked until the required amount of data, EOF or newline arrive at fd.</p>
<p>Possible errno values are described in read man page. As with fbr_read_all this function will never return -1 with EINTR.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a6b13f824e8810e439fe5356d021eb8a0" title="Fiber friendly libc read wrapper.">fbr_read</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ad83bfc4ecfcab4d968e599be39b7d4df" title="Even more fiber friendly libc read wrapper.">fbr_read_all</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00912">912</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a55e114145e071051ae58315dc4de5702"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_reclaim </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>fiber</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Reclaims a fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fiber</td><td>fiber pointer </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>-1 on error with f_errno set, 0 upon success</dd></dl>
<p>Fibers are never destroyed, but reclaimed. Reclamation frees some resources like call lists and memory pools immediately while keeping fiber structure itself and its stack as is. Reclaimed fiber is prepended to the reclaimed fiber list and will be served as a new one whenever next fbr_create is called. Fiber is prepended because it is warm in terms of cpu cache and its use might be faster than any other fiber in the list.</p>
<p>When you have some reclaimed fibers in the list, reclaiming and creating are generally cheap operations. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00432">432</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ae2012bda21beeb68ac2ba999b3b5214c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_recv </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly libc recv wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sockfd</td><td>file descriptor to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>maximum number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>just flags, see man recvfrom for details </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success, -1 in case of error and errno set</dd></dl>
<p>This function is used to receive messages from a socket.</p>
<p>Possible errno values are described in recv man page. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01049">1049</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="af81cbfa2b930dcfa0a4bb583bd8fb200"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_recvfrom </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">struct sockaddr *&#160;</td>
          <td class="paramname"><em>src_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t *&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly libc recvfrom wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sockfd</td><td>file descriptor to read from </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>maximum number of bytes to read </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>just flags, see man recvfrom for details </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">src_addr</td><td>source address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>size of src_addr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success, -1 in case of error and errno set</dd></dl>
<p>This function is used to receive messages from a socket.</p>
<p>Possible errno values are described in recvfrom man page. The only special case is EINTR which is handled internally and is returned to the caller only in case when non-root fiber called the fiber sitting in fbr_recvfrom. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01027">1027</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a91c339204d8fb63e6cb35b27e96eaa9e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a> fbr_self </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns id of current fiber. </p>
<dl class="section return"><dt>Returns</dt><dd>fbr_id_t of current fiber being executed. </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00516">516</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="aca093ce5ce596e42bc5372be92c81b7c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_send </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly libc send wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sockfd</td><td>file descriptor to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>maximum number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>just flags, see man sendto for details </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success, -1 in case of error and errno set</dd></dl>
<p>This function is used to send messages to a socket. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01092">1092</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4fd5418def62a64016aa8275a380e20e"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_sendto </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>sockfd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>len</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">int&#160;</td>
          <td class="paramname"><em>flags</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const struct sockaddr *&#160;</td>
          <td class="paramname"><em>dest_addr</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">socklen_t&#160;</td>
          <td class="paramname"><em>addrlen</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly libc sendto wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">sockfd</td><td>file descriptor to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">len</td><td>maximum number of bytes to write </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">flags</td><td>just flags, see man sendto for details </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">dest_addr</td><td>destination address </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">addrlen</td><td>size of dest_addr </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success, -1 in case of error and errno set</dd></dl>
<p>This function is used to send messages to a socket.</p>
<p>Possible errno values are described in sendto man page. The only special case is EINTR which is handled internally and is returned to the caller only in case when non-root fiber called the fiber sitting in fbr_sendto. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01070">1070</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ade47de6332577b83545d4e424ab1c5d1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_set_name </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets a name for the fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>identificator of a fiber </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">name</td><td>new name for a fiber </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on error.</dd></dl>
<p>The name is located in the statically allocated buffer of size FBR_MAX_FIBER_NAME. If your name does not fit, it will be trimmed.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a8ca58482ab7f2386cee302b51f58ef2b" title="Retrieve a name of the fiber.">fbr_get_name</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01753">1753</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a18f052d0f9f909a5da184158fa7e423f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_set_user_data </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">void *&#160;</td>
          <td class="paramname"><em>data</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Sets fiber user data pointer. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">id</td><td>fiber id </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">data</td><td>pointer to user data </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 upon failure with f_errno set</dd></dl>
<p>This function allows you to extend fiber with some user structure. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a61c95ede48cd9c6cb157c869eb77da75" title="Gets fiber user data pointer.">fbr_get_user_data</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01652">1652</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac13bb8634c1e28ca12b86e8c1a298545"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ev_tstamp fbr_sleep </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> ev_tstamp&#160;</td>
          <td class="paramname"><em>seconds</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Puts current fiber to sleep. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">seconds</td><td>maximum number of seconds to sleep </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of seconds actually being asleep</dd></dl>
<p>This function is used to put current fiber into sleep. It will wake up after the desired time has passed or earlier if some other fiber has called it. </p>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01139">1139</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a490cd2689aedc1ca0e60404a47b7f550"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">const char* fbr_strerror </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> enum <a class="el" href="fiber_8h.html#a4b8cb982994caa4c72046dd2970fa5a6">fbr_error_code</a>&#160;</td>
          <td class="paramname"><em>code</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Analog of strerror but for the library errno. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">code</td><td>Error code to describe </td></tr>
  </table>
  </dd>
</dl>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="structfbr__context.html" title="Library context structure, should be initialized before any other library calls will be performed...">fbr_context</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#a4b8cb982994caa4c72046dd2970fa5a6" title="Error codes used within the library.">fbr_error_code</a> </dd></dl>

</div>
</div>
<a class="anchor" id="a0e6f58c891a8cbf336bdd677314e535c"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_transfer </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> <a class="el" href="fiber_8h.html#ad08a37907434cf705119847ed590a089">fbr_id_t</a>&#160;</td>
          <td class="paramname"><em>to</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Transfer of fiber context to another fiber. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">to</td><td>callee id </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on success, -1 on failure with f_errno set.</dd></dl>
<p>This function transfers the execution context to other fiber. It returns as soon as the called fiber yields. In case of error it returns immediately. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#aac7f380431691642e6ef83962fb77ea1" title="Yields execution to other fiber.">fbr_yield</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00742">742</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ac88be5097d268184abc535adc0dbb00b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_vrb_destroy </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfbr__vrb.html">fbr_vrb</a> *&#160;</td>
          <td class="paramname"><em>vrb</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Destroys mappings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrb</td><td>a pointer to <a class="el" href="structfbr__vrb.html" title="Virtual ring buffer implementation.">fbr_vrb</a></td></tr>
  </table>
  </dd>
</dl>
<p>This function unmaps all the mappings done by fbr_vrb_init.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#ad5cc8bd85290403c550612114dfc960b" title="Initializes memory mappings.">fbr_vrb_init</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01545">1545</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ad5cc8bd85290403c550612114dfc960b"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">int fbr_vrb_init </td>
          <td>(</td>
          <td class="paramtype">struct <a class="el" href="structfbr__vrb.html">fbr_vrb</a> *&#160;</td>
          <td class="paramname"><em>vrb</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>size</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const char *&#160;</td>
          <td class="paramname"><em>file_pattern</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Initializes memory mappings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">vrb</td><td>a pointer to <a class="el" href="structfbr__vrb.html" title="Virtual ring buffer implementation.">fbr_vrb</a> </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">size</td><td>length of the data </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">file_pattern</td><td>file name patterm for underlying mmap storage </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>0 on succes, -1 on error.</dd></dl>
<p>This function mmaps adjacent virtual memory regions of required size which correspond to the same physical memory region. Also it adds two page-sized regions on the left and on the right with PROT_NONE access as a guards.</p>
<p>It does mmaps on the same file, which is unlinked and closed afterwards, so it will not pollute file descriptor space of a process and the filesystem.</p>
<dl class="section see"><dt>See Also</dt><dd>struct <a class="el" href="structfbr__vrb.html" title="Virtual ring buffer implementation.">fbr_vrb</a> </dd>
<dd>
<a class="el" href="fiber_8h.html#ac88be5097d268184abc535adc0dbb00b" title="Destroys mappings.">fbr_vrb_destroy</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l01452">1452</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="a4ebe4a182414d71fc76c0e18b5d7b63f"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_write </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Fiber friendly libc write wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>maximum number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes written on success, -1 in case of error and errno set</dd></dl>
<p>Attempts to write up to count bytes to file descriptor fd from the buffer starting at buf. Calling fiber will be blocked until the data is written.</p>
<p>Possible errno values are described in write man page. The only special case is EINTR which is handled internally and is returned to the caller only in case when non-root fiber called the fiber sitting in fbr_write.</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#ab16cc864979562e8b06eb26c7516a98d" title="Even more fiber friendly libc write wrapper.">fbr_write_all</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00957">957</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="ab16cc864979562e8b06eb26c7516a98d"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">ssize_t fbr_write_all </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#a1d223ea2c3abc8cc7e3b4b9f80fb733e">FBR_P_</a> int&#160;</td>
          <td class="paramname"><em>fd</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const void *&#160;</td>
          <td class="paramname"><em>buf</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>count</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Even more fiber friendly libc write wrapper. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramdir">[in]</td><td class="paramname">fd</td><td>file descriptor to write to </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">buf</td><td>pointer to some user-allocated buffer </td></tr>
    <tr><td class="paramdir">[in]</td><td class="paramname">count</td><td>desired number of bytes to write </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>number of bytes read on success, -1 in case of error and errno set</dd></dl>
<p>Attempts to write exactly count bytes to file descriptor fd from the buffer starting at buf. Calling fiber will be blocked until the required amount of data is written to fd.</p>
<p>Possible errno values are described in write man page. Unlike fbr_write this function will never return -1 with EINTR and will silently ignore any attempts to call this fiber from other non-root fibers (call infos are still queued if the called desired to do so).</p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a4ebe4a182414d71fc76c0e18b5d7b63f" title="Fiber friendly libc write wrapper.">fbr_write</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00982">982</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
<a class="anchor" id="aac7f380431691642e6ef83962fb77ea1"></a>
<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void fbr_yield </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="fiber_8h.html#ab8d0d2be00346d846c594c685bc04914">FBR_P</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Yields execution to other fiber. </p>
<p>When a fiber is waiting for some incoming event &mdash; it should yield. This will pop current fiber from the fiber stack and transfer the execution context to the next fiber from the stack making that fiber a new current one.</p>
<p>It loops through all fibers subscribed to specified multicast group id. </p>
<dl class="section see"><dt>See Also</dt><dd><a class="el" href="fiber_8h.html#a0e6f58c891a8cbf336bdd677314e535c" title="Transfer of fiber context to another fiber.">fbr_transfer</a> </dd></dl>

<p>Definition at line <a class="el" href="fiber_8c_source.html#l00759">759</a> of file <a class="el" href="fiber_8c_source.html">fiber.c</a>.</p>

</div>
</div>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="dir_d44c64559bbebec7f509842c48db8b23.html">include</a></li><li class="navelem"><a class="el" href="dir_5566bd5272a8f8db2e6a21f1105b917f.html">evfibers</a></li><li class="navelem"><a class="el" href="fiber_8h.html">fiber.h</a></li>
    <li class="footer">Generated on Thu Mar 13 2014 17:32:09 for libevfibers by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.1.2 </li>
  </ul>
</div>
</body>
</html>
