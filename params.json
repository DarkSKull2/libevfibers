{"name":"Libevfibers","tagline":"Small C fiber library","body":"# About libevfibers\r\nSmall C fiber library that uses libev based event loop and libcoro based coroutine context switching. As libcoro alone is barely enough to do something useful, this project aims at building a complete fiber api around it while leveraging libev's high performance and flexibility.\r\n\r\nAPI documentation for current master along with general description is located [here](http://lupus.github.io/libevfibers/docs/current/index.html).\r\n\r\n# What fibers are you speaking about?\r\n\r\nA fiber is an independent execution context of your program. Unlike classic approach, when you have your `main' being the only execution context, you can have as many of them as you like and switch between them at will. Wait, but that sounds like threads! Well, yes, it really does. Fibers are like threads, but implemented completely within user space without any kernel-level scheduling mechanisms. Main difference between fibers and threads is the scheduling model. Fibers use cooperative multitasking while threads exercise preemptive multitasking. The former requires some cooperation between fibers: if one takes all of the CPU time running in a busy loop (or blocks on e.g. read()) others will not have a chance to run. On the other hand it has some advantages:\r\n* user space context switching is cheap (just save/restore all registers and adjust couple of variables in the scheduler)\r\n* less synchronization is required --- as you have a guarantee that no other piece of code will be executed concurrently, you don't have to bother with mutex locks around each shared object\r\n\r\nFibers also may be viewed as an enhancement of event-loop driven applications as they enable you to put all business logic in one function instead of splitting it in several callbacks (without extra processing overhead). For example, if you implement a network protocol, you can just create a fiber per each client tcp connection and use fbr_read_all/fbr_write_all to fully read and write protocol messages. You don't have to bother about low-level details of how much data was read during this syscall and how much is left. Your fiber will proceed when the required amount of data is read (or an error occurred). This greatly simplifies the protocol processing logic.\r\n\r\n# Recent changes\r\n## 12 May 2013\r\nI've just released libevfibers 0.3.0!\r\n\r\nThis release contains important bugfixes and some useful features. Documentation for this release can be found [here](http://lupus.github.io/libevfibers/docs/v0.3.0/index.html). The list of changes follows:\r\n\r\n* Fiber names are now gettable/settable\r\n* Also a name is now an array, embedded into a fiber structure to simplify memory management.\r\n* Support for fiber-local storage\r\n* fbr_reclaim fixes. Now when a fiber is reclaimed, it's filtered out from the stack to make sure that fbr_yield will not ield to a reclaimed fiber. Also fbr_reclaim of self will now never return.\r\n* Switched fbr_need_log and fbr_set_log_level to static inline\r\n* Now passing real fiber stack size to coro_create\r\n* Added ``active'' flag to destructor. To support this I've also added static and dynamic initializers for a destructor structure.\r\n* Moved fbr_mutex, fbr_cond_var, fbr_buffer into public API to allow stack allocation of these structures which should result in some speedup.\r\n* Protected libev watchers with desctructors. Now when doing fbr_read a destructor is set before fbr_ev_wait that will stop the watcher in case fiber is reclaimed while we were waiting.\r\n* ev_now() timestamp in default logger\r\n* Fixed fbr_ev_wait_one behaviour to match documentation\r\n* Added missing call of destructors upon fiber reclaim\r\n* Added stack-allocatable destructor API\r\n* More rethinking and reworking of the event facility (see [701e067](https://github.com/Lupus/libevfibers/commit/701e0671c29ceaa75882ff25b7fd55a0462d5610))\r\n\r\n## 9 December 2012\r\nI've just released libevfibers 0.2.0!\r\n\r\nAPI has changed quite a lot from the previous release. Hopefully this API will be more stable and will not be changed that much in the future. Documentation for this release can be found [here](http://lupus.github.io/libevfibers/docs/v0.2.0/index.html). The list of changes follows:\r\n\r\n* Dropped \"call\" and \"multicall\" interfaces alltogether\r\n* Added fbr_ev_wait and corresponding machinery\r\n* Added transactional ring buffer\r\n* Implemented error subsystem with f_errno\r\n* Fixed ABA problem with reclaimed fibers\r\n* Added logging system\r\n* Added conditional variables\r\n* Minor utility additions to API\r\n* Unit tests","google":"UA-35569049-2","note":"Don't delete this file! It's used internally to help with page regeneration."}